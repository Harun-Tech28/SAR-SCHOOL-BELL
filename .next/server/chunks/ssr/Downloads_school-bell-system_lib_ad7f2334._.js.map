{"version":3,"sources":["../../../../../../Downloads/school-bell-system/lib/ai-voice-constants.ts","../../../../../../Downloads/school-bell-system/lib/prayer-call-generator.ts","../../../../../../Downloads/school-bell-system/lib/combined-audio.ts","../../../../../../Downloads/school-bell-system/lib/ai-voice-types.ts","../../../../../../Downloads/school-bell-system/lib/providers/openai-provider.ts","../../../../../../Downloads/school-bell-system/lib/providers/elevenlabs-provider.ts","../../../../../../Downloads/school-bell-system/lib/providers/azure-provider.ts","../../../../../../Downloads/school-bell-system/lib/providers/provider-factory.ts","../../../../../../Downloads/school-bell-system/lib/audio-cache.ts","../../../../../../Downloads/school-bell-system/lib/cache-manager.ts","../../../../../../Downloads/school-bell-system/lib/rate-limiter.ts","../../../../../../Downloads/school-bell-system/lib/ai-voice-service.ts","../../../../../../Downloads/school-bell-system/lib/voice-fallback.ts","../../../../../../Downloads/school-bell-system/lib/voice-utils.ts","../../../../../../Downloads/school-bell-system/lib/high-quality-announcements.ts"],"sourcesContent":["import type { AIVoiceProfile, ProviderCapabilities, AIVoiceProviderType } from \"./ai-voice-types\"\r\n\r\n// Default voice profiles for each provider\r\nexport const DEFAULT_VOICE_PROFILES: Record<AIVoiceProviderType, AIVoiceProfile[]> = {\r\n  openai: [\r\n    {\r\n      id: \"openai-alloy\",\r\n      name: \"Alloy\",\r\n      language: \"english\",\r\n      gender: \"neutral\",\r\n      category: \"standard\",\r\n      provider: \"openai\"\r\n    },\r\n    {\r\n      id: \"openai-echo\",\r\n      name: \"Echo\",\r\n      language: \"english\", \r\n      gender: \"male\",\r\n      category: \"announcement\",\r\n      provider: \"openai\"\r\n    },\r\n    {\r\n      id: \"openai-fable\",\r\n      name: \"Fable\",\r\n      language: \"english\",\r\n      gender: \"neutral\",\r\n      category: \"standard\",\r\n      provider: \"openai\"\r\n    },\r\n    {\r\n      id: \"openai-onyx\",\r\n      name: \"Onyx\",\r\n      language: \"english\",\r\n      gender: \"male\",\r\n      category: \"announcement\",\r\n      provider: \"openai\"\r\n    },\r\n    {\r\n      id: \"openai-nova\",\r\n      name: \"Nova\",\r\n      language: \"english\",\r\n      gender: \"female\",\r\n      category: \"standard\",\r\n      provider: \"openai\"\r\n    },\r\n    {\r\n      id: \"openai-shimmer\",\r\n      name: \"Shimmer\",\r\n      language: \"english\",\r\n      gender: \"female\",\r\n      category: \"announcement\",\r\n      provider: \"openai\"\r\n    }\r\n  ],\r\n  elevenlabs: [\r\n    {\r\n      id: \"elevenlabs-rachel\",\r\n      name: \"Rachel\",\r\n      language: \"english\",\r\n      gender: \"female\",\r\n      accent: \"american\",\r\n      category: \"standard\",\r\n      provider: \"elevenlabs\"\r\n    },\r\n    {\r\n      id: \"elevenlabs-drew\",\r\n      name: \"Drew\",\r\n      language: \"english\",\r\n      gender: \"male\",\r\n      accent: \"american\",\r\n      category: \"announcement\",\r\n      provider: \"elevenlabs\"\r\n    },\r\n    {\r\n      id: \"elevenlabs-clyde\",\r\n      name: \"Clyde\",\r\n      language: \"english\",\r\n      gender: \"male\",\r\n      accent: \"american\",\r\n      category: \"standard\",\r\n      provider: \"elevenlabs\"\r\n    },\r\n    {\r\n      id: \"elevenlabs-paul\",\r\n      name: \"Paul\",\r\n      language: \"english\",\r\n      gender: \"male\",\r\n      accent: \"american\",\r\n      category: \"announcement\",\r\n      provider: \"elevenlabs\"\r\n    }\r\n  ],\r\n  azure: [\r\n    {\r\n      id: \"azure-jenny\",\r\n      name: \"Jenny\",\r\n      language: \"english\",\r\n      gender: \"female\",\r\n      accent: \"american\",\r\n      category: \"standard\",\r\n      provider: \"azure\"\r\n    },\r\n    {\r\n      id: \"azure-guy\",\r\n      name: \"Guy\",\r\n      language: \"english\",\r\n      gender: \"male\",\r\n      accent: \"american\",\r\n      category: \"announcement\",\r\n      provider: \"azure\"\r\n    },\r\n    {\r\n      id: \"azure-aria\",\r\n      name: \"Aria\",\r\n      language: \"english\",\r\n      gender: \"female\",\r\n      accent: \"american\",\r\n      category: \"announcement\",\r\n      provider: \"azure\"\r\n    },\r\n    {\r\n      id: \"azure-davis\",\r\n      name: \"Davis\",\r\n      language: \"english\",\r\n      gender: \"male\",\r\n      accent: \"american\",\r\n      category: \"standard\",\r\n      provider: \"azure\"\r\n    }\r\n  ]\r\n}\r\n\r\n// Provider capabilities\r\nexport const PROVIDER_CAPABILITIES: Record<AIVoiceProviderType, ProviderCapabilities> = {\r\n  openai: {\r\n    maxCharacters: 4096,\r\n    supportedLanguages: [\"english\", \"spanish\", \"french\", \"german\", \"italian\", \"portuguese\", \"russian\", \"japanese\", \"korean\", \"chinese\", \"arabic\"],\r\n    supportedFormats: [\"mp3\", \"opus\", \"aac\", \"flac\"],\r\n    realTimeGeneration: true,\r\n    voiceCloning: false,\r\n    emotionControl: false\r\n  },\r\n  elevenlabs: {\r\n    maxCharacters: 5000,\r\n    supportedLanguages: [\"english\", \"spanish\", \"french\", \"german\", \"italian\", \"portuguese\", \"polish\", \"hindi\", \"arabic\"],\r\n    supportedFormats: [\"mp3\", \"wav\", \"ogg\"],\r\n    realTimeGeneration: true,\r\n    voiceCloning: true,\r\n    emotionControl: true\r\n  },\r\n  azure: {\r\n    maxCharacters: 10000,\r\n    supportedLanguages: [\"english\", \"spanish\", \"french\", \"german\", \"italian\", \"portuguese\", \"russian\", \"japanese\", \"korean\", \"chinese\", \"arabic\", \"hindi\", \"dutch\", \"swedish\"],\r\n    supportedFormats: [\"mp3\", \"wav\", \"ogg\", \"webm\"],\r\n    realTimeGeneration: true,\r\n    voiceCloning: false,\r\n    emotionControl: true\r\n  }\r\n}\r\n\r\n// Islamic prayer phrases in Arabic with transliteration\r\nexport const PRAYER_PHRASES = {\r\n  fajr: {\r\n    arabic: \"حي على الصلاة، حي على الفلاح، الصلاة خير من النوم\",\r\n    transliteration: \"Hayya 'ala as-salah, hayya 'ala al-falah, as-salatu khayrun min an-nawm\",\r\n    english: \"Come to prayer, come to success, prayer is better than sleep\"\r\n  },\r\n  dhuhr: {\r\n    arabic: \"حي على الصلاة، حي على الفلاح\",\r\n    transliteration: \"Hayya 'ala as-salah, hayya 'ala al-falah\",\r\n    english: \"Come to prayer, come to success\"\r\n  },\r\n  asr: {\r\n    arabic: \"حي على الصلاة، حي على الفلاح\",\r\n    transliteration: \"Hayya 'ala as-salah, hayya 'ala al-falah\",\r\n    english: \"Come to prayer, come to success\"\r\n  },\r\n  maghrib: {\r\n    arabic: \"حي على الصلاة، حي على الفلاح\",\r\n    transliteration: \"Hayya 'ala as-salah, hayya 'ala al-falah\",\r\n    english: \"Come to prayer, come to success\"\r\n  },\r\n  isha: {\r\n    arabic: \"حي على الصلاة، حي على الفلاح\",\r\n    transliteration: \"Hayya 'ala as-salah, hayya 'ala al-falah\",\r\n    english: \"Come to prayer, come to success\"\r\n  }\r\n}\r\n\r\n// Bell and announcement templates\r\nexport const AUDIO_TEMPLATES = {\r\n  bell: {\r\n    class: \"School bell - Class time\",\r\n    break: \"School bell - Break time\",\r\n    assembly: \"School bell - Assembly time\",\r\n    dismissal: \"School bell - Dismissal time\"\r\n  },\r\n  announcement: {\r\n    attention: \"Attention students and staff\",\r\n    general: \"This is a general announcement\",\r\n    emergency: \"This is an emergency announcement\"\r\n  }\r\n}\r\n\r\n// Cache key generation\r\nexport const generateCacheKey = (text: string, voice: string, provider: string): string => {\r\n  const hash = btoa(text + voice + provider).replace(/[^a-zA-Z0-9]/g, '').substring(0, 32)\r\n  return `ai-voice-${provider}-${voice}-${hash}`\r\n}\r\n\r\n// Cost estimation (approximate costs per 1000 characters)\r\nexport const PROVIDER_COSTS: Record<AIVoiceProviderType, number> = {\r\n  openai: 0.015, // $0.015 per 1000 characters\r\n  elevenlabs: 0.30, // $0.30 per 1000 characters\r\n  azure: 0.016 // $0.016 per 1000 characters\r\n}\r\n\r\n// Rate limiting defaults\r\nexport const DEFAULT_RATE_LIMITS = {\r\n  openai: {\r\n    requestsPerMinute: 50,\r\n    charactersPerDay: 50000\r\n  },\r\n  elevenlabs: {\r\n    requestsPerMinute: 20,\r\n    charactersPerDay: 20000\r\n  },\r\n  azure: {\r\n    requestsPerMinute: 100,\r\n    charactersPerDay: 100000\r\n  }\r\n}","import { PRAYER_PHRASES } from \"./ai-voice-constants\"\r\n\r\nexport interface PrayerCallOptions {\r\n  includeArabic?: boolean\r\n  includeTransliteration?: boolean\r\n  includeEnglish?: boolean\r\n  includeBasmala?: boolean\r\n  includeTakbir?: boolean\r\n  customMessage?: string\r\n  voiceStyle?: 'traditional' | 'modern' | 'simple'\r\n}\r\n\r\nexport interface PrayerCallContent {\r\n  arabic: string\r\n  transliteration: string\r\n  english: string\r\n  combined: string\r\n  metadata: {\r\n    prayer: string\r\n    timestamp: number\r\n    style: string\r\n    components: string[]\r\n  }\r\n}\r\n\r\nexport class PrayerCallGenerator {\r\n  private readonly TAKBIR = \"الله أكبر الله أكبر\" // Allahu Akbar Allahu Akbar\r\n  private readonly TAKBIR_TRANSLITERATION = \"Allahu Akbar Allahu Akbar\"\r\n  private readonly TAKBIR_ENGLISH = \"Allah is the Greatest, Allah is the Greatest\"\r\n\r\n  private readonly BASMALA = \"بسم الله الرحمن الرحيم\" // Bismillah ar-Rahman ar-Raheem\r\n  private readonly BASMALA_TRANSLITERATION = \"Bismillah ar-Rahman ar-Raheem\"\r\n  private readonly BASMALA_ENGLISH = \"In the name of Allah, the Most Gracious, the Most Merciful\"\r\n\r\n  private readonly SHAHADA = \"أشهد أن لا إله إلا الله، أشهد أن محمداً رسول الله\"\r\n  private readonly SHAHADA_TRANSLITERATION = \"Ashhadu an la ilaha illa Allah, Ashhadu anna Muhammadan rasul Allah\"\r\n  private readonly SHAHADA_ENGLISH = \"I bear witness that there is no god but Allah, I bear witness that Muhammad is the messenger of Allah\"\r\n\r\n  generatePrayerCall(\r\n    prayerName: string,\r\n    options: PrayerCallOptions = {}\r\n  ): PrayerCallContent {\r\n    const defaultOptions: Required<PrayerCallOptions> = {\r\n      includeArabic: true,\r\n      includeTransliteration: true,\r\n      includeEnglish: true,\r\n      includeBasmala: false,\r\n      includeTakbir: true,\r\n      customMessage: '',\r\n      voiceStyle: 'traditional'\r\n    }\r\n\r\n    const opts = { ...defaultOptions, ...options }\r\n    const prayer = prayerName.toLowerCase()\r\n    const components: string[] = []\r\n\r\n    let arabicText = ''\r\n    let transliterationText = ''\r\n    let englishText = ''\r\n\r\n    // Add Basmala if requested\r\n    if (opts.includeBasmala) {\r\n      if (opts.includeArabic) arabicText += this.BASMALA + '. '\r\n      if (opts.includeTransliteration) transliterationText += this.BASMALA_TRANSLITERATION + '. '\r\n      if (opts.includeEnglish) englishText += this.BASMALA_ENGLISH + '. '\r\n      components.push('basmala')\r\n    }\r\n\r\n    // Add Takbir if requested\r\n    if (opts.includeTakbir) {\r\n      if (opts.includeArabic) arabicText += this.TAKBIR + '. '\r\n      if (opts.includeTransliteration) transliterationText += this.TAKBIR_TRANSLITERATION + '. '\r\n      if (opts.includeEnglish) englishText += this.TAKBIR_ENGLISH + '. '\r\n      components.push('takbir')\r\n    }\r\n\r\n    // Add prayer-specific content\r\n    const prayerContent = this.getPrayerSpecificContent(prayer)\r\n    if (prayerContent) {\r\n      if (opts.includeArabic) arabicText += prayerContent.arabic + '. '\r\n      if (opts.includeTransliteration) transliterationText += prayerContent.transliteration + '. '\r\n      if (opts.includeEnglish) englishText += prayerContent.english + '. '\r\n      components.push('prayer-call')\r\n    }\r\n\r\n    // Add Shahada for traditional style\r\n    if (opts.voiceStyle === 'traditional') {\r\n      if (opts.includeArabic) arabicText += this.SHAHADA + '. '\r\n      if (opts.includeTransliteration) transliterationText += this.SHAHADA_TRANSLITERATION + '. '\r\n      if (opts.includeEnglish) englishText += this.SHAHADA_ENGLISH + '. '\r\n      components.push('shahada')\r\n    }\r\n\r\n    // Add prayer time announcement\r\n    const timeAnnouncement = this.getPrayerTimeAnnouncement(prayer)\r\n    if (opts.includeEnglish) englishText += timeAnnouncement + '. '\r\n    components.push('time-announcement')\r\n\r\n    // Add custom message if provided\r\n    if (opts.customMessage) {\r\n      if (opts.includeEnglish) englishText += opts.customMessage + '. '\r\n      components.push('custom-message')\r\n    }\r\n\r\n    // Create combined text based on style\r\n    const combined = this.createCombinedText(\r\n      arabicText.trim(),\r\n      transliterationText.trim(),\r\n      englishText.trim(),\r\n      opts.voiceStyle\r\n    )\r\n\r\n    return {\r\n      arabic: arabicText.trim(),\r\n      transliteration: transliterationText.trim(),\r\n      english: englishText.trim(),\r\n      combined,\r\n      metadata: {\r\n        prayer: prayerName,\r\n        timestamp: Date.now(),\r\n        style: opts.voiceStyle,\r\n        components\r\n      }\r\n    }\r\n  }\r\n\r\n  private getPrayerSpecificContent(prayer: string): {\r\n    arabic: string\r\n    transliteration: string\r\n    english: string\r\n  } | null {\r\n    const prayerData = PRAYER_PHRASES[prayer as keyof typeof PRAYER_PHRASES]\r\n    if (!prayerData) return null\r\n\r\n    return {\r\n      arabic: prayerData.arabic,\r\n      transliteration: prayerData.transliteration,\r\n      english: prayerData.english\r\n    }\r\n  }\r\n\r\n  private getPrayerTimeAnnouncement(prayer: string): string {\r\n    const prayerNames: Record<string, string> = {\r\n      fajr: \"Fajr prayer time\",\r\n      dhuhr: \"Dhuhr prayer time\", \r\n      asr: \"Asr prayer time\",\r\n      maghrib: \"Maghrib prayer time\",\r\n      isha: \"Isha prayer time\"\r\n    }\r\n\r\n    return prayerNames[prayer] || `${prayer.charAt(0).toUpperCase() + prayer.slice(1)} prayer time`\r\n  }\r\n\r\n  private createCombinedText(\r\n    arabic: string,\r\n    transliteration: string,\r\n    english: string,\r\n    style: 'traditional' | 'modern' | 'simple'\r\n  ): string {\r\n    switch (style) {\r\n      case 'traditional':\r\n        // Arabic first, then transliteration, then English\r\n        return [arabic, transliteration, english].filter(Boolean).join(' ')\r\n      \r\n      case 'modern':\r\n        // Mix Arabic and English for modern audiences\r\n        return [arabic, english].filter(Boolean).join(' ')\r\n      \r\n      case 'simple':\r\n        // English only for simplicity\r\n        return english\r\n      \r\n      default:\r\n        return [arabic, english].filter(Boolean).join(' ')\r\n    }\r\n  }\r\n\r\n  // Generate prayer call for specific times with contextual content\r\n  generateContextualPrayerCall(\r\n    prayerName: string,\r\n    currentTime: Date,\r\n    options: PrayerCallOptions = {}\r\n  ): PrayerCallContent {\r\n    const hour = currentTime.getHours()\r\n    const contextualOptions = { ...options }\r\n\r\n    // Add contextual elements based on time\r\n    switch (prayerName.toLowerCase()) {\r\n      case 'fajr':\r\n        // Dawn prayer - emphasize waking up\r\n        contextualOptions.customMessage = \"Wake up for the dawn prayer. Prayer is better than sleep.\"\r\n        break\r\n      \r\n      case 'dhuhr':\r\n        // Noon prayer - during work/school hours\r\n        contextualOptions.customMessage = \"Take a break from your activities for the noon prayer.\"\r\n        break\r\n      \r\n      case 'asr':\r\n        // Afternoon prayer\r\n        contextualOptions.customMessage = \"Time for the afternoon prayer before sunset.\"\r\n        break\r\n      \r\n      case 'maghrib':\r\n        // Sunset prayer - end of day\r\n        contextualOptions.customMessage = \"The sun has set. Time for Maghrib prayer.\"\r\n        break\r\n      \r\n      case 'isha':\r\n        // Night prayer\r\n        contextualOptions.customMessage = \"Complete your day with the night prayer.\"\r\n        break\r\n    }\r\n\r\n    return this.generatePrayerCall(prayerName, contextualOptions)\r\n  }\r\n\r\n  // Generate prayer call with school-specific context\r\n  generateSchoolPrayerCall(\r\n    prayerName: string,\r\n    schoolContext: {\r\n      isSchoolHours?: boolean\r\n      hasStudents?: boolean\r\n      location?: string\r\n    } = {},\r\n    options: PrayerCallOptions = {}\r\n  ): PrayerCallContent {\r\n    const contextualOptions = { ...options }\r\n\r\n    if (schoolContext.isSchoolHours && schoolContext.hasStudents) {\r\n      // School-specific messaging\r\n      const schoolMessages: Record<string, string> = {\r\n        fajr: \"Students and staff, it's time for Fajr prayer before school begins.\",\r\n        dhuhr: \"Students and staff, please proceed to the prayer area for Dhuhr prayer.\",\r\n        asr: \"Students and staff, time for Asr prayer. Classes will resume after prayer.\",\r\n        maghrib: \"Students and staff, Maghrib prayer time. School day is ending.\",\r\n        isha: \"Students and staff, time for Isha prayer before going home.\"\r\n      }\r\n\r\n      const schoolMessage = schoolMessages[prayerName.toLowerCase()]\r\n      if (schoolMessage) {\r\n        contextualOptions.customMessage = schoolMessage\r\n      }\r\n    }\r\n\r\n    if (schoolContext.location) {\r\n      contextualOptions.customMessage = \r\n        (contextualOptions.customMessage || '') + \r\n        ` Please gather at ${schoolContext.location}.`\r\n    }\r\n\r\n    return this.generatePrayerCall(prayerName, contextualOptions)\r\n  }\r\n\r\n  // Generate multiple language versions\r\n  generateMultilingualPrayerCall(\r\n    prayerName: string,\r\n    languages: Array<'arabic' | 'english' | 'hausa' | 'twi'>,\r\n    options: PrayerCallOptions = {}\r\n  ): Record<string, PrayerCallContent> {\r\n    const results: Record<string, PrayerCallContent> = {}\r\n\r\n    for (const language of languages) {\r\n      const langOptions = { ...options }\r\n      \r\n      switch (language) {\r\n        case 'arabic':\r\n          langOptions.includeArabic = true\r\n          langOptions.includeEnglish = false\r\n          langOptions.includeTransliteration = false\r\n          break\r\n        \r\n        case 'english':\r\n          langOptions.includeArabic = false\r\n          langOptions.includeEnglish = true\r\n          langOptions.includeTransliteration = true\r\n          break\r\n        \r\n        case 'hausa':\r\n        case 'twi':\r\n          // For local languages, include English and transliteration\r\n          langOptions.includeArabic = true\r\n          langOptions.includeEnglish = true\r\n          langOptions.includeTransliteration = true\r\n          // Add local language greeting\r\n          langOptions.customMessage = this.getLocalLanguageGreeting(language, prayerName)\r\n          break\r\n      }\r\n\r\n      results[language] = this.generatePrayerCall(prayerName, langOptions)\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n  private getLocalLanguageGreeting(language: 'hausa' | 'twi', prayerName: string): string {\r\n    const greetings: Record<string, Record<string, string>> = {\r\n      hausa: {\r\n        fajr: \"Lokacin sallah ta asuba ya yi. Ku zo mu yi sallah.\",\r\n        dhuhr: \"Lokacin sallah ta rana ya yi. Ku zo mu yi sallah.\",\r\n        asr: \"Lokacin sallah ta yamma ya yi. Ku zo mu yi sallah.\",\r\n        maghrib: \"Lokacin sallah ta magariba ya yi. Ku zo mu yi sallah.\",\r\n        isha: \"Lokacin sallah ta dare ya yi. Ku zo mu yi sallah.\"\r\n      },\r\n      twi: {\r\n        fajr: \"Anɔpa mpaebɔ berɛ aso. Mommra yɛn kɔ bɔ mpae.\",\r\n        dhuhr: \"Awia mpaebɔ berɛ aso. Mommra yɛn kɔ bɔ mpae.\",\r\n        asr: \"Anwummere mpaebɔ berɛ aso. Mommra yɛn kɔ bɔ mpae.\",\r\n        maghrib: \"Anwummere mpaebɔ berɛ aso. Mommra yɛn kɔ bɔ mpae.\",\r\n        isha: \"Anadwo mpaebɔ berɛ aso. Mommra yɛn kɔ bɔ mpae.\"\r\n      }\r\n    }\r\n\r\n    return greetings[language]?.[prayerName.toLowerCase()] || \r\n           `Time for ${prayerName} prayer. Come and pray.`\r\n  }\r\n\r\n  // Validate prayer call content\r\n  validatePrayerCall(content: PrayerCallContent): {\r\n    valid: boolean\r\n    errors: string[]\r\n    warnings: string[]\r\n  } {\r\n    const errors: string[] = []\r\n    const warnings: string[] = []\r\n\r\n    // Check if content is not empty\r\n    if (!content.combined.trim()) {\r\n      errors.push(\"Prayer call content is empty\")\r\n    }\r\n\r\n    // Check for minimum required components\r\n    if (!content.metadata.components.includes('prayer-call')) {\r\n      warnings.push(\"Prayer call does not include traditional prayer phrases\")\r\n    }\r\n\r\n    if (!content.metadata.components.includes('time-announcement')) {\r\n      warnings.push(\"Prayer call does not include time announcement\")\r\n    }\r\n\r\n    // Check Arabic content if included\r\n    if (content.arabic && !this.containsArabicText(content.arabic)) {\r\n      warnings.push(\"Arabic content may not contain proper Arabic text\")\r\n    }\r\n\r\n    // Check length (should not be too long for voice generation)\r\n    if (content.combined.length > 1000) {\r\n      warnings.push(\"Prayer call content is very long and may affect voice generation quality\")\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings\r\n    }\r\n  }\r\n\r\n  private containsArabicText(text: string): boolean {\r\n    // Check if text contains Arabic characters\r\n    const arabicRegex = /[\\u0600-\\u06FF]/\r\n    return arabicRegex.test(text)\r\n  }\r\n\r\n  // Get prayer call statistics\r\n  getContentStatistics(content: PrayerCallContent): {\r\n    totalLength: number\r\n    arabicLength: number\r\n    englishLength: number\r\n    wordCount: number\r\n    estimatedDuration: number // in seconds\r\n    components: string[]\r\n  } {\r\n    const words = content.combined.split(/\\s+/).filter(word => word.length > 0)\r\n    \r\n    return {\r\n      totalLength: content.combined.length,\r\n      arabicLength: content.arabic.length,\r\n      englishLength: content.english.length,\r\n      wordCount: words.length,\r\n      estimatedDuration: Math.ceil(words.length * 0.6), // ~0.6 seconds per word\r\n      components: content.metadata.components\r\n    }\r\n  }\r\n}\r\n\r\n// Global prayer call generator instance\r\nlet prayerCallGeneratorInstance: PrayerCallGenerator | null = null\r\n\r\nexport const getPrayerCallGenerator = (): PrayerCallGenerator => {\r\n  if (!prayerCallGeneratorInstance) {\r\n    prayerCallGeneratorInstance = new PrayerCallGenerator()\r\n  }\r\n  return prayerCallGeneratorInstance\r\n}\r\n\r\n// Convenience functions\r\nexport const generateSimplePrayerCall = (prayerName: string): string => {\r\n  const generator = getPrayerCallGenerator()\r\n  const content = generator.generatePrayerCall(prayerName, {\r\n    voiceStyle: 'simple',\r\n    includeArabic: false,\r\n    includeTransliteration: false,\r\n    includeEnglish: true\r\n  })\r\n  return content.combined\r\n}\r\n\r\nexport const generateTraditionalPrayerCall = (prayerName: string): string => {\r\n  const generator = getPrayerCallGenerator()\r\n  const content = generator.generatePrayerCall(prayerName, {\r\n    voiceStyle: 'traditional',\r\n    includeBasmala: true,\r\n    includeTakbir: true\r\n  })\r\n  return content.combined\r\n}\r\n\r\nexport const generateSchoolPrayerCall = (\r\n  prayerName: string,\r\n  isSchoolHours: boolean = true\r\n): string => {\r\n  const generator = getPrayerCallGenerator()\r\n  const content = generator.generateSchoolPrayerCall(prayerName, {\r\n    isSchoolHours,\r\n    hasStudents: true,\r\n    location: \"prayer area\"\r\n  })\r\n  return content.combined\r\n}","import { playBellSound } from \"./bell-sounds\"\r\nimport { playAnnouncement } from \"./voice-utils\"\r\nimport { useStore } from \"./store\"\r\nimport type { BellType } from \"./bell-sounds\"\r\nimport type { VoiceType, Language } from \"./store\"\r\n\r\nexport interface CombinedAudioOptions {\r\n  tone?: BellType\r\n  voice?: VoiceType\r\n  language?: Language\r\n  repeatCount?: number\r\n  delayBetweenToneAndVoice?: number\r\n  delayBetweenRepeats?: number\r\n}\r\n\r\nexport class CombinedAudioPlayer {\r\n  static async playToneAndAnnouncement(\r\n    taskName: string,\r\n    options: CombinedAudioOptions = {}\r\n  ): Promise<boolean> {\r\n    const settings = useStore.getState().settings\r\n    const {\r\n      tone = \"bell\",\r\n      voice = settings.defaultVoice,\r\n      language = settings.defaultLanguage,\r\n      repeatCount = settings.defaultRepeatCount,\r\n      delayBetweenToneAndVoice = 1500,\r\n      delayBetweenRepeats = 3000\r\n    } = options\r\n\r\n    console.log(`[CombinedAudio] Playing ${repeatCount} time(s): ${tone} + \"${taskName}\"`)\r\n\r\n    let allSuccessful = true\r\n\r\n    for (let i = 0; i < repeatCount; i++) {\r\n      console.log(`[CombinedAudio] Repetition ${i + 1} of ${repeatCount}`)\r\n      \r\n      try {\r\n        // 1. Play the tone first\r\n        console.log(`[CombinedAudio] Playing ${tone} tone...`)\r\n        playBellSound(tone)\r\n        \r\n        // 2. Wait for tone to finish\r\n        await new Promise(resolve => setTimeout(resolve, delayBetweenToneAndVoice))\r\n        \r\n        // 3. Play voice announcement\r\n        console.log(`[CombinedAudio] Playing voice announcement: \"${taskName}\"`)\r\n        const voiceSuccess = await playAnnouncement(taskName, voice, language, 1) // Single announcement per repetition\r\n        \r\n        if (!voiceSuccess) {\r\n          allSuccessful = false\r\n          console.error(`[CombinedAudio] Voice announcement failed for repetition ${i + 1}`)\r\n        }\r\n        \r\n        // 4. Wait between repetitions (except for the last one)\r\n        if (i < repeatCount - 1) {\r\n          console.log(`[CombinedAudio] Waiting ${delayBetweenRepeats}ms before next repetition...`)\r\n          await new Promise(resolve => setTimeout(resolve, delayBetweenRepeats))\r\n        }\r\n      } catch (error) {\r\n        allSuccessful = false\r\n        console.error(`[CombinedAudio] Error in repetition ${i + 1}:`, error)\r\n      }\r\n    }\r\n\r\n    console.log(`[CombinedAudio] Completed ${repeatCount} repetitions. Success: ${allSuccessful}`)\r\n    return allSuccessful\r\n  }\r\n\r\n  // Specific functions for different task types\r\n  static async playClassBell(taskName: string, options?: Partial<CombinedAudioOptions>): Promise<boolean> {\r\n    return this.playToneAndAnnouncement(taskName, {\r\n      tone: \"bell\",\r\n      delayBetweenToneAndVoice: 2000, // Longer delay for bell\r\n      ...options\r\n    })\r\n  }\r\n\r\n  static async playBreakChime(taskName: string, options?: Partial<CombinedAudioOptions>): Promise<boolean> {\r\n    return this.playToneAndAnnouncement(taskName, {\r\n      tone: \"chime\",\r\n      delayBetweenToneAndVoice: 1000, // Shorter delay for chime\r\n      ...options\r\n    })\r\n  }\r\n\r\n  static async playAnnouncement(taskName: string, options?: Partial<CombinedAudioOptions>): Promise<boolean> {\r\n    return this.playToneAndAnnouncement(taskName, {\r\n      tone: \"announcement\",\r\n      delayBetweenToneAndVoice: 800, // Quick notification sound\r\n      ...options\r\n    })\r\n  }\r\n\r\n  static async playEmergencyAlert(taskName: string, options?: Partial<CombinedAudioOptions>): Promise<boolean> {\r\n    return this.playToneAndAnnouncement(taskName, {\r\n      tone: \"emergency-alert\",\r\n      delayBetweenToneAndVoice: 500, // Immediate voice after emergency tone\r\n      repeatCount: 3, // Emergency alerts repeat more\r\n      delayBetweenRepeats: 2000, // Shorter delay for urgency\r\n      ...options\r\n    })\r\n  }\r\n\r\n  // High-quality AI voice announcement (no tone, just premium voice)\r\n  static async playHighQualityAnnouncement(\r\n    message: string, \r\n    options?: Partial<CombinedAudioOptions>\r\n  ): Promise<boolean> {\r\n    const settings = useStore.getState().settings\r\n    const {\r\n      voice = \"openai-nova\", // Default to high-quality AI voice\r\n      language = settings.defaultLanguage,\r\n      repeatCount = settings.defaultRepeatCount\r\n    } = options || {}\r\n\r\n    console.log(`[CombinedAudio] Playing high-quality announcement: \"${message}\"`)\r\n\r\n    let allSuccessful = true\r\n\r\n    for (let i = 0; i < repeatCount; i++) {\r\n      console.log(`[CombinedAudio] High-quality announcement repetition ${i + 1} of ${repeatCount}`)\r\n      \r\n      try {\r\n        const voiceSuccess = await playAnnouncement(message, voice, language, 1)\r\n        \r\n        if (!voiceSuccess) {\r\n          allSuccessful = false\r\n          console.error(`[CombinedAudio] High-quality announcement failed for repetition ${i + 1}`)\r\n        }\r\n        \r\n        // Wait between repetitions (except for the last one)\r\n        if (i < repeatCount - 1) {\r\n          await new Promise(resolve => setTimeout(resolve, 3000))\r\n        }\r\n      } catch (error) {\r\n        allSuccessful = false\r\n        console.error(`[CombinedAudio] Error in high-quality announcement repetition ${i + 1}:`, error)\r\n      }\r\n    }\r\n\r\n    console.log(`[CombinedAudio] High-quality announcement completed. Success: ${allSuccessful}`)\r\n    return allSuccessful\r\n  }\r\n\r\n  // Normal announcement with tone + high-quality AI voice\r\n  static async playNormalAnnouncement(\r\n    message: string,\r\n    options?: Partial<CombinedAudioOptions>\r\n  ): Promise<boolean> {\r\n    return this.playToneAndAnnouncement(message, {\r\n      tone: \"announcement\",\r\n      voice: \"openai-nova\", // High-quality AI voice\r\n      delayBetweenToneAndVoice: 800,\r\n      ...options\r\n    })\r\n  }\r\n\r\n  // Smart task-based audio player\r\n  static async playTaskAudio(\r\n    taskName: string,\r\n    taskType: string,\r\n    bellType?: BellType,\r\n    options?: Partial<CombinedAudioOptions>\r\n  ): Promise<boolean> {\r\n    console.log(`[CombinedAudio] Playing task audio for: \"${taskName}\" (Type: ${taskType}, Bell: ${bellType})`)\r\n    \r\n    // Determine appropriate tone and settings based on task type and bell type\r\n    let tone: BellType = bellType || \"bell\"\r\n    let delayBetweenToneAndVoice = 1500\r\n    let voiceMessage = taskName\r\n\r\n    // Customize based on task type\r\n    switch (taskType.toLowerCase()) {\r\n      case \"class\":\r\n      case \"lesson\":\r\n        tone = bellType || \"bell\"\r\n        delayBetweenToneAndVoice = 2000\r\n        voiceMessage = `Attention all students, it is time for ${taskName}. Please proceed to your classrooms.`\r\n        break\r\n      case \"break\":\r\n      case \"recess\":\r\n        tone = bellType || \"chime\"\r\n        delayBetweenToneAndVoice = 1000\r\n        voiceMessage = `Attention all students, it is time for ${taskName}. You may now leave your classrooms.`\r\n        break\r\n      case \"assembly\":\r\n      case \"meeting\":\r\n        tone = bellType || \"announcement\"\r\n        delayBetweenToneAndVoice = 800\r\n        voiceMessage = `Attention all students and staff, it is time for ${taskName}. Please proceed to the assembly hall.`\r\n        break\r\n      case \"lunch\":\r\n      case \"meal\":\r\n        tone = bellType || \"chime\"\r\n        delayBetweenToneAndVoice = 1200\r\n        voiceMessage = `Attention all students, it is time for ${taskName}. Please proceed to the dining hall.`\r\n        break\r\n      case \"dismissal\":\r\n      case \"end\":\r\n        tone = bellType || \"dismissal-bell\"\r\n        delayBetweenToneAndVoice = 2000\r\n        voiceMessage = `Attention all students, it is time for ${taskName}. Please collect your belongings and proceed to the exit.`\r\n        break\r\n      case \"emergency\":\r\n      case \"drill\":\r\n        tone = bellType || \"emergency-alert\"\r\n        delayBetweenToneAndVoice = 500\r\n        voiceMessage = `Emergency alert. ${taskName}. All students and staff must follow emergency procedures immediately.`\r\n        break\r\n      default:\r\n        // Use provided bell type or default\r\n        tone = bellType || \"bell\"\r\n        voiceMessage = `Attention all students, it is time for ${taskName}.`\r\n    }\r\n\r\n    return this.playToneAndAnnouncement(voiceMessage, {\r\n      tone,\r\n      delayBetweenToneAndVoice,\r\n      ...options\r\n    })\r\n  }\r\n\r\n  // Get appropriate tone for task type\r\n  static getToneForTaskType(taskType: string): BellType {\r\n    switch (taskType.toLowerCase()) {\r\n      case \"class\":\r\n      case \"lesson\":\r\n      case \"dismissal\":\r\n        return \"bell\"\r\n      case \"break\":\r\n      case \"recess\":\r\n      case \"lunch\":\r\n        return \"chime\"\r\n      case \"assembly\":\r\n      case \"meeting\":\r\n      case \"announcement\":\r\n        return \"announcement\"\r\n      case \"emergency\":\r\n      case \"drill\":\r\n        return \"emergency-alert\"\r\n      default:\r\n        return \"bell\"\r\n    }\r\n  }\r\n\r\n  // Generate appropriate voice message for task\r\n  static generateVoiceMessage(taskName: string, taskType: string): string {\r\n    const baseMessages: Record<string, string> = {\r\n      class: `Attention all students, it is time for ${taskName}. Please proceed to your classrooms.`,\r\n      lesson: `Attention all students, it is time for ${taskName}. Please proceed to your classrooms.`,\r\n      break: `Attention all students, it is time for ${taskName}. You may now leave your classrooms.`,\r\n      recess: `Attention all students, it is time for ${taskName}. You may now leave your classrooms.`,\r\n      lunch: `Attention all students, it is time for ${taskName}. Please proceed to the dining hall.`,\r\n      assembly: `Attention all students and staff, it is time for ${taskName}. Please proceed to the assembly hall.`,\r\n      meeting: `Attention all students and staff, it is time for ${taskName}. Please proceed to the designated area.`,\r\n      announcement: `Attention all students and staff, it is time for ${taskName}. Please listen carefully.`,\r\n      dismissal: `Attention all students, it is time for ${taskName}. Please collect your belongings and proceed to the exit.`,\r\n      end: `Attention all students, it is time for ${taskName}. Please collect your belongings and proceed to the exit.`,\r\n      emergency: `Emergency alert. ${taskName}. All students and staff must follow emergency procedures immediately.`,\r\n      drill: `Emergency drill. ${taskName}. All students and staff must follow drill procedures immediately.`\r\n    }\r\n\r\n    return baseMessages[taskType.toLowerCase()] || `Attention all students, it is time for ${taskName}.`\r\n  }\r\n}\r\n\r\n// Export convenience functions\r\nexport const playToneAndAnnouncement = (taskName: string, options?: CombinedAudioOptions) =>\r\n  CombinedAudioPlayer.playToneAndAnnouncement(taskName, options)\r\n\r\nexport const playClassBell = (taskName: string, options?: Partial<CombinedAudioOptions>) =>\r\n  CombinedAudioPlayer.playClassBell(taskName, options)\r\n\r\nexport const playBreakChime = (taskName: string, options?: Partial<CombinedAudioOptions>) =>\r\n  CombinedAudioPlayer.playBreakChime(taskName, options)\r\n\r\nexport const playAnnouncementTone = (taskName: string, options?: Partial<CombinedAudioOptions>) =>\r\n  CombinedAudioPlayer.playAnnouncement(taskName, options)\r\n\r\nexport const playEmergencyAlert = (taskName: string, options?: Partial<CombinedAudioOptions>) =>\r\n  CombinedAudioPlayer.playEmergencyAlert(taskName, options)\r\n\r\nexport const playHighQualityAnnouncement = (message: string, options?: Partial<CombinedAudioOptions>) =>\r\n  CombinedAudioPlayer.playHighQualityAnnouncement(message, options)\r\n\r\nexport const playNormalAnnouncement = (message: string, options?: Partial<CombinedAudioOptions>) =>\r\n  CombinedAudioPlayer.playNormalAnnouncement(message, options)\r\n\r\nexport const playTaskAudio = (taskName: string, taskType: string, bellType?: BellType, options?: Partial<CombinedAudioOptions>) =>\r\n  CombinedAudioPlayer.playTaskAudio(taskName, taskType, bellType, options)\r\n\r\nexport const getToneForTaskType = (taskType: string) => CombinedAudioPlayer.getToneForTaskType(taskType)\r\n\r\nexport const generateVoiceMessage = (taskName: string, taskType: string) => \r\n  CombinedAudioPlayer.generateVoiceMessage(taskName, taskType)\r\n\r\n// Make it available globally for console testing\r\nif (typeof window !== \"undefined\") {\r\n  (window as any).CombinedAudioPlayer = CombinedAudioPlayer;\r\n  (window as any).playToneAndAnnouncement = playToneAndAnnouncement;\r\n  (window as any).playTaskAudio = playTaskAudio;\r\n  (window as any).playHighQualityAnnouncement = playHighQualityAnnouncement;\r\n  (window as any).playNormalAnnouncement = playNormalAnnouncement;\r\n}","// Core AI Voice Generation Types and Interfaces\r\n\r\nexport interface AIVoiceProvider {\r\n  name: string\r\n  generateSpeech(text: string, options: VoiceOptions): Promise<AudioBuffer>\r\n  getAvailableVoices(): Promise<AIVoiceProfile[]>\r\n  validateCredentials(): Promise<boolean>\r\n  estimateCost(text: string, voice: string): number\r\n}\r\n\r\nexport interface VoiceOptions {\r\n  voice: string\r\n  language: string\r\n  speed: number\r\n  pitch: number\r\n  stability?: number\r\n  clarity?: number\r\n}\r\n\r\nexport interface AIVoiceProfile {\r\n  id: string\r\n  name: string\r\n  language: string\r\n  gender: 'male' | 'female' | 'neutral'\r\n  accent?: string\r\n  category: 'standard' | 'religious' | 'announcement' | 'bell'\r\n  provider: string\r\n  previewUrl?: string\r\n}\r\n\r\nexport interface AudioCacheManager {\r\n  store(key: string, audio: AudioBuffer, metadata: CacheMetadata): Promise<void>\r\n  retrieve(key: string): Promise<AudioBuffer | null>\r\n  exists(key: string): Promise<boolean>\r\n  clear(pattern?: string): Promise<void>\r\n  getUsageStats(): Promise<CacheStats>\r\n  cleanup(): Promise<void>\r\n}\r\n\r\nexport interface CacheMetadata {\r\n  text: string\r\n  voice: string\r\n  provider: string\r\n  timestamp: number\r\n  size: number\r\n  usage: number\r\n}\r\n\r\nexport interface CacheStats {\r\n  totalSize: number\r\n  totalFiles: number\r\n  hitRate: number\r\n  oldestFile: number\r\n  newestFile: number\r\n}\r\n\r\nexport interface ProviderConfig {\r\n  apiKey: string\r\n  endpoint?: string\r\n  enabled: boolean\r\n  priority: number\r\n  rateLimit: {\r\n    requestsPerMinute: number\r\n    charactersPerDay: number\r\n  }\r\n}\r\n\r\nexport interface AIVoiceSettings {\r\n  aiVoiceEnabled: boolean\r\n  primaryProvider: string\r\n  fallbackProvider?: string\r\n  voiceProfiles: {\r\n    announcement: AIVoiceProfile\r\n    prayer: AIVoiceProfile\r\n    bell: AIVoiceProfile\r\n    general: AIVoiceProfile\r\n  }\r\n  cacheSettings: {\r\n    maxSize: number // MB\r\n    maxAge: number // days\r\n    enabled: boolean\r\n  }\r\n  usageSettings: {\r\n    monthlyLimit: number // characters\r\n    costThreshold: number // USD\r\n    optimizationEnabled: boolean\r\n  }\r\n  providerConfigs: Record<string, ProviderConfig>\r\n}\r\n\r\nexport interface AudioGenerationRequest {\r\n  id: string\r\n  text: string\r\n  type: 'announcement' | 'prayer' | 'bell' | 'general'\r\n  voice: AIVoiceProfile\r\n  options: VoiceOptions\r\n  priority: 'high' | 'normal' | 'low'\r\n  timestamp: number\r\n  status: 'pending' | 'generating' | 'completed' | 'failed' | 'cached'\r\n  retryCount: number\r\n  estimatedCost: number\r\n}\r\n\r\nexport interface UsageRecord {\r\n  id: string\r\n  timestamp: number\r\n  provider: string\r\n  voice: string\r\n  characterCount: number\r\n  cost: number\r\n  type: 'announcement' | 'prayer' | 'bell' | 'general'\r\n  cached: boolean\r\n}\r\n\r\nexport interface UsageStats {\r\n  currentMonth: {\r\n    totalCharacters: number\r\n    totalCost: number\r\n    requestCount: number\r\n    cacheHitRate: number\r\n  }\r\n  byProvider: Record<string, {\r\n    characters: number\r\n    cost: number\r\n    requests: number\r\n  }>\r\n  byType: Record<string, {\r\n    characters: number\r\n    cost: number\r\n    requests: number\r\n  }>\r\n}\r\n\r\n// Provider-specific types\r\nexport type AIVoiceProviderType = 'openai' | 'elevenlabs' | 'azure'\r\n\r\nexport interface ProviderCapabilities {\r\n  maxCharacters: number\r\n  supportedLanguages: string[]\r\n  supportedFormats: string[]\r\n  realTimeGeneration: boolean\r\n  voiceCloning: boolean\r\n  emotionControl: boolean\r\n}\r\n\r\n// Error types for AI voice operations\r\nexport class AIVoiceError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public provider: string,\r\n    public code: string,\r\n    public retryable: boolean = false\r\n  ) {\r\n    super(message)\r\n    this.name = 'AIVoiceError'\r\n  }\r\n}\r\n\r\nexport class RateLimitError extends AIVoiceError {\r\n  constructor(provider: string, retryAfter?: number) {\r\n    super(`Rate limit exceeded for ${provider}`, provider, 'RATE_LIMIT', true)\r\n    this.retryAfter = retryAfter\r\n  }\r\n  retryAfter?: number\r\n}\r\n\r\nexport class AuthenticationError extends AIVoiceError {\r\n  constructor(provider: string) {\r\n    super(`Authentication failed for ${provider}`, provider, 'AUTH_FAILED', false)\r\n  }\r\n}\r\n\r\nexport class ServiceUnavailableError extends AIVoiceError {\r\n  constructor(provider: string) {\r\n    super(`Service unavailable for ${provider}`, provider, 'SERVICE_UNAVAILABLE', true)\r\n  }\r\n}\r\n\r\n// Utility types\r\nexport type VoiceGenerationStatus = 'idle' | 'generating' | 'completed' | 'error'\r\n\r\nexport interface VoiceGenerationProgress {\r\n  status: VoiceGenerationStatus\r\n  progress: number // 0-100\r\n  message?: string\r\n  estimatedTimeRemaining?: number\r\n}","import type { AIVoiceProvider, VoiceOptions, AIVoiceProfile } from \"../ai-voice-types\"\r\nimport { AIVoiceError, RateLimitError, AuthenticationError, ServiceUnavailableError } from \"../ai-voice-types\"\r\nimport { PROVIDER_COSTS } from \"../ai-voice-constants\"\r\n\r\nexport class OpenAIProvider implements AIVoiceProvider {\r\n  name = \"OpenAI TTS\"\r\n  private apiKey: string\r\n  private baseUrl = \"https://api.openai.com/v1\"\r\n\r\n  constructor(apiKey: string) {\r\n    this.apiKey = apiKey\r\n  }\r\n\r\n  async generateSpeech(text: string, options: VoiceOptions): Promise<AudioBuffer> {\r\n    if (!this.apiKey) {\r\n      throw new AuthenticationError(\"OpenAI\")\r\n    }\r\n\r\n    const requestBody = {\r\n      model: \"tts-1\", // Use tts-1 for faster generation, tts-1-hd for higher quality\r\n      input: text,\r\n      voice: this.mapVoiceId(options.voice),\r\n      response_format: \"mp3\",\r\n      speed: Math.max(0.25, Math.min(4.0, options.speed)) // OpenAI supports 0.25 to 4.0\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/audio/speech`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Authorization\": `Bearer ${this.apiKey}`,\r\n          \"Content-Type\": \"application/json\"\r\n        },\r\n        body: JSON.stringify(requestBody)\r\n      })\r\n\r\n      if (!response.ok) {\r\n        await this.handleErrorResponse(response)\r\n      }\r\n\r\n      const arrayBuffer = await response.arrayBuffer()\r\n      return await this.convertMp3ToAudioBuffer(arrayBuffer)\r\n    } catch (error) {\r\n      if (error instanceof AIVoiceError) {\r\n        throw error\r\n      }\r\n      throw new ServiceUnavailableError(\"OpenAI\")\r\n    }\r\n  }\r\n\r\n  async getAvailableVoices(): Promise<AIVoiceProfile[]> {\r\n    // OpenAI TTS voices are predefined\r\n    return [\r\n      {\r\n        id: \"openai-alloy\",\r\n        name: \"Alloy\",\r\n        language: \"english\",\r\n        gender: \"neutral\",\r\n        category: \"standard\",\r\n        provider: \"openai\"\r\n      },\r\n      {\r\n        id: \"openai-echo\",\r\n        name: \"Echo\",\r\n        language: \"english\",\r\n        gender: \"male\",\r\n        category: \"announcement\",\r\n        provider: \"openai\"\r\n      },\r\n      {\r\n        id: \"openai-fable\",\r\n        name: \"Fable\",\r\n        language: \"english\",\r\n        gender: \"neutral\",\r\n        category: \"standard\",\r\n        provider: \"openai\"\r\n      },\r\n      {\r\n        id: \"openai-onyx\",\r\n        name: \"Onyx\",\r\n        language: \"english\",\r\n        gender: \"male\",\r\n        category: \"announcement\",\r\n        provider: \"openai\"\r\n      },\r\n      {\r\n        id: \"openai-nova\",\r\n        name: \"Nova\",\r\n        language: \"english\",\r\n        gender: \"female\",\r\n        category: \"standard\",\r\n        provider: \"openai\"\r\n      },\r\n      {\r\n        id: \"openai-shimmer\",\r\n        name: \"Shimmer\",\r\n        language: \"english\",\r\n        gender: \"female\",\r\n        category: \"announcement\",\r\n        provider: \"openai\"\r\n      }\r\n    ]\r\n  }\r\n\r\n  async validateCredentials(): Promise<boolean> {\r\n    if (!this.apiKey) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      // Test with a minimal request\r\n      const response = await fetch(`${this.baseUrl}/audio/speech`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Authorization\": `Bearer ${this.apiKey}`,\r\n          \"Content-Type\": \"application/json\"\r\n        },\r\n        body: JSON.stringify({\r\n          model: \"tts-1\",\r\n          input: \"test\",\r\n          voice: \"alloy\",\r\n          response_format: \"mp3\"\r\n        })\r\n      })\r\n\r\n      return response.ok || response.status === 400 // 400 might be due to minimal input, but auth is valid\r\n    } catch (error) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  estimateCost(text: string, voice: string): number {\r\n    const characterCount = text.length\r\n    return (characterCount / 1000) * PROVIDER_COSTS.openai\r\n  }\r\n\r\n  private mapVoiceId(voiceId: string): string {\r\n    // Map our voice IDs to OpenAI voice names\r\n    const voiceMap: Record<string, string> = {\r\n      \"openai-alloy\": \"alloy\",\r\n      \"openai-echo\": \"echo\",\r\n      \"openai-fable\": \"fable\",\r\n      \"openai-onyx\": \"onyx\",\r\n      \"openai-nova\": \"nova\",\r\n      \"openai-shimmer\": \"shimmer\"\r\n    }\r\n\r\n    return voiceMap[voiceId] || \"alloy\" // Default to alloy\r\n  }\r\n\r\n  private async handleErrorResponse(response: Response): Promise<never> {\r\n    const errorText = await response.text()\r\n    let errorData: any = {}\r\n    \r\n    try {\r\n      errorData = JSON.parse(errorText)\r\n    } catch {\r\n      // If JSON parsing fails, use the raw text\r\n    }\r\n\r\n    switch (response.status) {\r\n      case 401:\r\n        throw new AuthenticationError(\"OpenAI\")\r\n      case 429:\r\n        const retryAfter = response.headers.get(\"retry-after\")\r\n        throw new RateLimitError(\"OpenAI\", retryAfter ? parseInt(retryAfter) : undefined)\r\n      case 500:\r\n      case 502:\r\n      case 503:\r\n      case 504:\r\n        throw new ServiceUnavailableError(\"OpenAI\")\r\n      default:\r\n        throw new AIVoiceError(\r\n          errorData.error?.message || `OpenAI API error: ${response.status}`,\r\n          \"OpenAI\",\r\n          `HTTP_${response.status}`,\r\n          response.status >= 500\r\n        )\r\n    }\r\n  }\r\n\r\n  private async convertMp3ToAudioBuffer(mp3ArrayBuffer: ArrayBuffer): Promise<AudioBuffer> {\r\n    // Create AudioContext\r\n    const AudioContext = window.AudioContext || (window as any).webkitAudioContext\r\n    const audioContext = new AudioContext()\r\n\r\n    try {\r\n      // Decode the MP3 data\r\n      const audioBuffer = await audioContext.decodeAudioData(mp3ArrayBuffer.slice(0))\r\n      return audioBuffer\r\n    } catch (error) {\r\n      throw new AIVoiceError(\r\n        \"Failed to decode audio data from OpenAI\",\r\n        \"OpenAI\",\r\n        \"DECODE_ERROR\",\r\n        false\r\n      )\r\n    }\r\n  }\r\n\r\n  // Utility method to check if a language is supported\r\n  isLanguageSupported(language: string): boolean {\r\n    // OpenAI TTS supports many languages, but voices are primarily English\r\n    const supportedLanguages = [\r\n      \"english\", \"spanish\", \"french\", \"german\", \"italian\", \"portuguese\", \r\n      \"russian\", \"japanese\", \"korean\", \"chinese\", \"arabic\", \"hindi\", \"dutch\"\r\n    ]\r\n    return supportedLanguages.includes(language.toLowerCase())\r\n  }\r\n\r\n  // Get the maximum character limit for OpenAI\r\n  getMaxCharacters(): number {\r\n    return 4096\r\n  }\r\n\r\n  // Get supported audio formats\r\n  getSupportedFormats(): string[] {\r\n    return [\"mp3\", \"opus\", \"aac\", \"flac\"]\r\n  }\r\n\r\n  // Update API key\r\n  updateApiKey(apiKey: string): void {\r\n    this.apiKey = apiKey\r\n  }\r\n\r\n  // Get current API key (masked for security)\r\n  getApiKeyMask(): string {\r\n    if (!this.apiKey) return \"\"\r\n    return this.apiKey.substring(0, 7) + \"...\" + this.apiKey.substring(this.apiKey.length - 4)\r\n  }\r\n}","import type { AIVoiceProvider, VoiceOptions, AIVoiceProfile } from \"../ai-voice-types\"\r\nimport { AIVoiceError, RateLimitError, AuthenticationError, ServiceUnavailableError } from \"../ai-voice-types\"\r\nimport { PROVIDER_COSTS } from \"../ai-voice-constants\"\r\n\r\nexport class ElevenLabsProvider implements AIVoiceProvider {\r\n  name = \"ElevenLabs\"\r\n  private apiKey: string\r\n  private baseUrl = \"https://api.elevenlabs.io/v1\"\r\n\r\n  constructor(apiKey: string) {\r\n    this.apiKey = apiKey\r\n  }\r\n\r\n  async generateSpeech(text: string, options: VoiceOptions): Promise<AudioBuffer> {\r\n    if (!this.apiKey) {\r\n      throw new AuthenticationError(\"ElevenLabs\")\r\n    }\r\n\r\n    const voiceId = this.mapVoiceId(options.voice)\r\n    const requestBody = {\r\n      text: text,\r\n      model_id: \"eleven_monolingual_v1\", // Use multilingual for other languages\r\n      voice_settings: {\r\n        stability: options.stability || 0.5,\r\n        similarity_boost: options.clarity || 0.75,\r\n        style: 0.0,\r\n        use_speaker_boost: true\r\n      }\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/text-to-speech/${voiceId}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Accept\": \"audio/mpeg\",\r\n          \"Content-Type\": \"application/json\",\r\n          \"xi-api-key\": this.apiKey\r\n        },\r\n        body: JSON.stringify(requestBody)\r\n      })\r\n\r\n      if (!response.ok) {\r\n        await this.handleErrorResponse(response)\r\n      }\r\n\r\n      const arrayBuffer = await response.arrayBuffer()\r\n      return await this.convertMp3ToAudioBuffer(arrayBuffer)\r\n    } catch (error) {\r\n      if (error instanceof AIVoiceError) {\r\n        throw error\r\n      }\r\n      throw new ServiceUnavailableError(\"ElevenLabs\")\r\n    }\r\n  }\r\n\r\n  async getAvailableVoices(): Promise<AIVoiceProfile[]> {\r\n    if (!this.apiKey) {\r\n      // Return default voices if no API key\r\n      return this.getDefaultVoices()\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/voices`, {\r\n        headers: {\r\n          \"xi-api-key\": this.apiKey\r\n        }\r\n      })\r\n\r\n      if (!response.ok) {\r\n        // Fallback to default voices if API call fails\r\n        return this.getDefaultVoices()\r\n      }\r\n\r\n      const data = await response.json()\r\n      return this.mapElevenLabsVoices(data.voices || [])\r\n    } catch (error) {\r\n      // Fallback to default voices\r\n      return this.getDefaultVoices()\r\n    }\r\n  }\r\n\r\n  async validateCredentials(): Promise<boolean> {\r\n    if (!this.apiKey) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/user`, {\r\n        headers: {\r\n          \"xi-api-key\": this.apiKey\r\n        }\r\n      })\r\n\r\n      return response.ok\r\n    } catch (error) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  estimateCost(text: string, voice: string): number {\r\n    const characterCount = text.length\r\n    return (characterCount / 1000) * PROVIDER_COSTS.elevenlabs\r\n  }\r\n\r\n  private getDefaultVoices(): AIVoiceProfile[] {\r\n    return [\r\n      {\r\n        id: \"elevenlabs-rachel\",\r\n        name: \"Rachel\",\r\n        language: \"english\",\r\n        gender: \"female\",\r\n        accent: \"american\",\r\n        category: \"standard\",\r\n        provider: \"elevenlabs\"\r\n      },\r\n      {\r\n        id: \"elevenlabs-drew\",\r\n        name: \"Drew\",\r\n        language: \"english\",\r\n        gender: \"male\",\r\n        accent: \"american\",\r\n        category: \"announcement\",\r\n        provider: \"elevenlabs\"\r\n      },\r\n      {\r\n        id: \"elevenlabs-clyde\",\r\n        name: \"Clyde\",\r\n        language: \"english\",\r\n        gender: \"male\",\r\n        accent: \"american\",\r\n        category: \"standard\",\r\n        provider: \"elevenlabs\"\r\n      },\r\n      {\r\n        id: \"elevenlabs-paul\",\r\n        name: \"Paul\",\r\n        language: \"english\",\r\n        gender: \"male\",\r\n        accent: \"american\",\r\n        category: \"announcement\",\r\n        provider: \"elevenlabs\"\r\n      },\r\n      {\r\n        id: \"elevenlabs-domi\",\r\n        name: \"Domi\",\r\n        language: \"english\",\r\n        gender: \"female\",\r\n        accent: \"american\",\r\n        category: \"standard\",\r\n        provider: \"elevenlabs\"\r\n      },\r\n      {\r\n        id: \"elevenlabs-dave\",\r\n        name: \"Dave\",\r\n        language: \"english\",\r\n        gender: \"male\",\r\n        accent: \"british\",\r\n        category: \"announcement\",\r\n        provider: \"elevenlabs\"\r\n      }\r\n    ]\r\n  }\r\n\r\n  private mapElevenLabsVoices(voices: any[]): AIVoiceProfile[] {\r\n    return voices.map(voice => ({\r\n      id: `elevenlabs-${voice.voice_id}`,\r\n      name: voice.name,\r\n      language: this.detectLanguage(voice.labels || {}),\r\n      gender: this.detectGender(voice.labels || {}),\r\n      accent: this.detectAccent(voice.labels || {}),\r\n      category: this.detectCategory(voice.labels || {}),\r\n      provider: \"elevenlabs\",\r\n      previewUrl: voice.preview_url\r\n    }))\r\n  }\r\n\r\n  private detectLanguage(labels: any): string {\r\n    const language = labels.language || labels.accent || \"english\"\r\n    return language.toLowerCase()\r\n  }\r\n\r\n  private detectGender(labels: any): \"male\" | \"female\" | \"neutral\" {\r\n    const gender = labels.gender || labels.sex || \"\"\r\n    if (gender.toLowerCase().includes(\"male\")) return \"male\"\r\n    if (gender.toLowerCase().includes(\"female\")) return \"female\"\r\n    return \"neutral\"\r\n  }\r\n\r\n  private detectAccent(labels: any): string | undefined {\r\n    return labels.accent || labels.region || undefined\r\n  }\r\n\r\n  private detectCategory(labels: any): \"standard\" | \"religious\" | \"announcement\" | \"bell\" {\r\n    const description = (labels.description || \"\").toLowerCase()\r\n    const useCase = (labels.use_case || \"\").toLowerCase()\r\n    \r\n    if (description.includes(\"announcement\") || useCase.includes(\"announcement\")) {\r\n      return \"announcement\"\r\n    }\r\n    if (description.includes(\"religious\") || useCase.includes(\"religious\")) {\r\n      return \"religious\"\r\n    }\r\n    if (description.includes(\"bell\") || useCase.includes(\"bell\")) {\r\n      return \"bell\"\r\n    }\r\n    return \"standard\"\r\n  }\r\n\r\n  private mapVoiceId(voiceId: string): string {\r\n    // Map our voice IDs to ElevenLabs voice IDs\r\n    const voiceMap: Record<string, string> = {\r\n      \"elevenlabs-rachel\": \"21m00Tcm4TlvDq8ikWAM\",\r\n      \"elevenlabs-drew\": \"29vD33N1CtxCmqQRPOHJ\",\r\n      \"elevenlabs-clyde\": \"2EiwWnXFnvU5JabPnv8n\",\r\n      \"elevenlabs-paul\": \"5Q0t7uMcjvnagumLfvZi\",\r\n      \"elevenlabs-domi\": \"AZnzlk1XvdvUeBnXmlld\",\r\n      \"elevenlabs-dave\": \"CYw3kZ02Hs0563khs1Fj\"\r\n    }\r\n\r\n    // If it's already a direct voice ID (from API), use it\r\n    if (voiceId.length === 20 && !voiceId.includes(\"-\")) {\r\n      return voiceId\r\n    }\r\n\r\n    return voiceMap[voiceId] || \"21m00Tcm4TlvDq8ikWAM\" // Default to Rachel\r\n  }\r\n\r\n  private async handleErrorResponse(response: Response): Promise<never> {\r\n    const errorText = await response.text()\r\n    let errorData: any = {}\r\n    \r\n    try {\r\n      errorData = JSON.parse(errorText)\r\n    } catch {\r\n      // If JSON parsing fails, use the raw text\r\n    }\r\n\r\n    switch (response.status) {\r\n      case 401:\r\n        throw new AuthenticationError(\"ElevenLabs\")\r\n      case 429:\r\n        const retryAfter = response.headers.get(\"retry-after\")\r\n        throw new RateLimitError(\"ElevenLabs\", retryAfter ? parseInt(retryAfter) : undefined)\r\n      case 500:\r\n      case 502:\r\n      case 503:\r\n      case 504:\r\n        throw new ServiceUnavailableError(\"ElevenLabs\")\r\n      default:\r\n        throw new AIVoiceError(\r\n          errorData.detail?.message || errorData.message || `ElevenLabs API error: ${response.status}`,\r\n          \"ElevenLabs\",\r\n          `HTTP_${response.status}`,\r\n          response.status >= 500\r\n        )\r\n    }\r\n  }\r\n\r\n  private async convertMp3ToAudioBuffer(mp3ArrayBuffer: ArrayBuffer): Promise<AudioBuffer> {\r\n    // Create AudioContext\r\n    const AudioContext = window.AudioContext || (window as any).webkitAudioContext\r\n    const audioContext = new AudioContext()\r\n\r\n    try {\r\n      // Decode the MP3 data\r\n      const audioBuffer = await audioContext.decodeAudioData(mp3ArrayBuffer.slice(0))\r\n      return audioBuffer\r\n    } catch (error) {\r\n      throw new AIVoiceError(\r\n        \"Failed to decode audio data from ElevenLabs\",\r\n        \"ElevenLabs\",\r\n        \"DECODE_ERROR\",\r\n        false\r\n      )\r\n    }\r\n  }\r\n\r\n  // Utility method to check if a language is supported\r\n  isLanguageSupported(language: string): boolean {\r\n    const supportedLanguages = [\r\n      \"english\", \"spanish\", \"french\", \"german\", \"italian\", \"portuguese\", \r\n      \"polish\", \"hindi\", \"arabic\", \"japanese\", \"korean\", \"chinese\"\r\n    ]\r\n    return supportedLanguages.includes(language.toLowerCase())\r\n  }\r\n\r\n  // Get the maximum character limit for ElevenLabs\r\n  getMaxCharacters(): number {\r\n    return 5000\r\n  }\r\n\r\n  // Get supported audio formats\r\n  getSupportedFormats(): string[] {\r\n    return [\"mp3\", \"wav\", \"ogg\"]\r\n  }\r\n\r\n  // Update API key\r\n  updateApiKey(apiKey: string): void {\r\n    this.apiKey = apiKey\r\n  }\r\n\r\n  // Get current API key (masked for security)\r\n  getApiKeyMask(): string {\r\n    if (!this.apiKey) return \"\"\r\n    return this.apiKey.substring(0, 7) + \"...\" + this.apiKey.substring(this.apiKey.length - 4)\r\n  }\r\n\r\n  // ElevenLabs specific methods\r\n  async getVoiceSettings(voiceId: string): Promise<any> {\r\n    if (!this.apiKey) {\r\n      throw new AuthenticationError(\"ElevenLabs\")\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/voices/${voiceId}/settings`, {\r\n        headers: {\r\n          \"xi-api-key\": this.apiKey\r\n        }\r\n      })\r\n\r\n      if (!response.ok) {\r\n        throw new AIVoiceError(\"Failed to get voice settings\", \"ElevenLabs\", \"SETTINGS_ERROR\", false)\r\n      }\r\n\r\n      return await response.json()\r\n    } catch (error) {\r\n      if (error instanceof AIVoiceError) {\r\n        throw error\r\n      }\r\n      throw new ServiceUnavailableError(\"ElevenLabs\")\r\n    }\r\n  }\r\n\r\n  async getUserInfo(): Promise<any> {\r\n    if (!this.apiKey) {\r\n      throw new AuthenticationError(\"ElevenLabs\")\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/user`, {\r\n        headers: {\r\n          \"xi-api-key\": this.apiKey\r\n        }\r\n      })\r\n\r\n      if (!response.ok) {\r\n        throw new AIVoiceError(\"Failed to get user info\", \"ElevenLabs\", \"USER_INFO_ERROR\", false)\r\n      }\r\n\r\n      return await response.json()\r\n    } catch (error) {\r\n      if (error instanceof AIVoiceError) {\r\n        throw error\r\n      }\r\n      throw new ServiceUnavailableError(\"ElevenLabs\")\r\n    }\r\n  }\r\n}","import type { AIVoiceProvider, VoiceOptions, AIVoiceProfile } from \"../ai-voice-types\"\r\nimport { AIVoiceError, RateLimitError, AuthenticationError, ServiceUnavailableError } from \"../ai-voice-types\"\r\nimport { PROVIDER_COSTS } from \"../ai-voice-constants\"\r\n\r\nexport class AzureProvider implements AIVoiceProvider {\r\n  name = \"Azure Cognitive Services\"\r\n  private apiKey: string\r\n  private region: string\r\n  private baseUrl: string\r\n\r\n  constructor(apiKey: string, endpoint?: string) {\r\n    this.apiKey = apiKey\r\n    \r\n    // Extract region from endpoint or use default\r\n    if (endpoint) {\r\n      const match = endpoint.match(/https:\\/\\/([^.]+)\\.tts\\.speech\\.microsoft\\.com/)\r\n      this.region = match ? match[1] : \"eastus\"\r\n      this.baseUrl = endpoint\r\n    } else {\r\n      this.region = \"eastus\"\r\n      this.baseUrl = `https://${this.region}.tts.speech.microsoft.com`\r\n    }\r\n  }\r\n\r\n  async generateSpeech(text: string, options: VoiceOptions): Promise<AudioBuffer> {\r\n    if (!this.apiKey) {\r\n      throw new AuthenticationError(\"Azure\")\r\n    }\r\n\r\n    // Get access token first\r\n    const accessToken = await this.getAccessToken()\r\n    \r\n    const voiceInfo = this.mapVoiceId(options.voice)\r\n    const ssml = this.generateSSML(text, voiceInfo, options)\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/cognitiveservices/v1`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Authorization\": `Bearer ${accessToken}`,\r\n          \"Content-Type\": \"application/ssml+xml\",\r\n          \"X-Microsoft-OutputFormat\": \"audio-16khz-128kbitrate-mono-mp3\",\r\n          \"User-Agent\": \"SchoolBellSystem\"\r\n        },\r\n        body: ssml\r\n      })\r\n\r\n      if (!response.ok) {\r\n        await this.handleErrorResponse(response)\r\n      }\r\n\r\n      const arrayBuffer = await response.arrayBuffer()\r\n      return await this.convertMp3ToAudioBuffer(arrayBuffer)\r\n    } catch (error) {\r\n      if (error instanceof AIVoiceError) {\r\n        throw error\r\n      }\r\n      throw new ServiceUnavailableError(\"Azure\")\r\n    }\r\n  }\r\n\r\n  async getAvailableVoices(): Promise<AIVoiceProfile[]> {\r\n    if (!this.apiKey) {\r\n      return this.getDefaultVoices()\r\n    }\r\n\r\n    try {\r\n      const accessToken = await this.getAccessToken()\r\n      const response = await fetch(`${this.baseUrl}/cognitiveservices/voices/list`, {\r\n        headers: {\r\n          \"Authorization\": `Bearer ${accessToken}`\r\n        }\r\n      })\r\n\r\n      if (!response.ok) {\r\n        return this.getDefaultVoices()\r\n      }\r\n\r\n      const voices = await response.json()\r\n      return this.mapAzureVoices(voices)\r\n    } catch (error) {\r\n      return this.getDefaultVoices()\r\n    }\r\n  }\r\n\r\n  async validateCredentials(): Promise<boolean> {\r\n    if (!this.apiKey) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      const accessToken = await this.getAccessToken()\r\n      return !!accessToken\r\n    } catch (error) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  estimateCost(text: string, voice: string): number {\r\n    const characterCount = text.length\r\n    return (characterCount / 1000) * PROVIDER_COSTS.azure\r\n  }\r\n\r\n  private async getAccessToken(): Promise<string> {\r\n    const tokenUrl = `https://${this.region}.api.cognitive.microsoft.com/sts/v1.0/issueToken`\r\n    \r\n    try {\r\n      const response = await fetch(tokenUrl, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Ocp-Apim-Subscription-Key\": this.apiKey,\r\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        },\r\n        body: \"\"\r\n      })\r\n\r\n      if (!response.ok) {\r\n        if (response.status === 401 || response.status === 403) {\r\n          throw new AuthenticationError(\"Azure\")\r\n        }\r\n        throw new ServiceUnavailableError(\"Azure\")\r\n      }\r\n\r\n      return await response.text()\r\n    } catch (error) {\r\n      if (error instanceof AIVoiceError) {\r\n        throw error\r\n      }\r\n      throw new ServiceUnavailableError(\"Azure\")\r\n    }\r\n  }\r\n\r\n  private generateSSML(text: string, voiceInfo: any, options: VoiceOptions): string {\r\n    const rate = this.mapSpeedToRate(options.speed)\r\n    const pitch = this.mapPitchToSSML(options.pitch)\r\n    \r\n    return `\r\n      <speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xml:lang=\"${voiceInfo.locale}\">\r\n        <voice name=\"${voiceInfo.name}\">\r\n          <prosody rate=\"${rate}\" pitch=\"${pitch}\">\r\n            ${this.escapeXML(text)}\r\n          </prosody>\r\n        </voice>\r\n      </speak>\r\n    `.trim()\r\n  }\r\n\r\n  private mapSpeedToRate(speed: number): string {\r\n    // Convert speed (0.25-4.0) to Azure rate format\r\n    if (speed <= 0.5) return \"x-slow\"\r\n    if (speed <= 0.75) return \"slow\"\r\n    if (speed <= 1.25) return \"medium\"\r\n    if (speed <= 1.5) return \"fast\"\r\n    return \"x-fast\"\r\n  }\r\n\r\n  private mapPitchToSSML(pitch: number): string {\r\n    // Convert pitch (0.5-2.0) to Azure pitch format\r\n    if (pitch <= 0.75) return \"low\"\r\n    if (pitch <= 1.25) return \"medium\"\r\n    return \"high\"\r\n  }\r\n\r\n  private escapeXML(text: string): string {\r\n    return text\r\n      .replace(/&/g, \"&amp;\")\r\n      .replace(/</g, \"&lt;\")\r\n      .replace(/>/g, \"&gt;\")\r\n      .replace(/\"/g, \"&quot;\")\r\n      .replace(/'/g, \"&apos;\")\r\n  }\r\n\r\n  private getDefaultVoices(): AIVoiceProfile[] {\r\n    return [\r\n      {\r\n        id: \"azure-jenny\",\r\n        name: \"Jenny\",\r\n        language: \"english\",\r\n        gender: \"female\",\r\n        accent: \"american\",\r\n        category: \"standard\",\r\n        provider: \"azure\"\r\n      },\r\n      {\r\n        id: \"azure-guy\",\r\n        name: \"Guy\",\r\n        language: \"english\",\r\n        gender: \"male\",\r\n        accent: \"american\",\r\n        category: \"announcement\",\r\n        provider: \"azure\"\r\n      },\r\n      {\r\n        id: \"azure-aria\",\r\n        name: \"Aria\",\r\n        language: \"english\",\r\n        gender: \"female\",\r\n        accent: \"american\",\r\n        category: \"announcement\",\r\n        provider: \"azure\"\r\n      },\r\n      {\r\n        id: \"azure-davis\",\r\n        name: \"Davis\",\r\n        language: \"english\",\r\n        gender: \"male\",\r\n        accent: \"american\",\r\n        category: \"standard\",\r\n        provider: \"azure\"\r\n      },\r\n      {\r\n        id: \"azure-jane\",\r\n        name: \"Jane\",\r\n        language: \"english\",\r\n        gender: \"female\",\r\n        accent: \"american\",\r\n        category: \"standard\",\r\n        provider: \"azure\"\r\n      },\r\n      {\r\n        id: \"azure-jason\",\r\n        name: \"Jason\",\r\n        language: \"english\",\r\n        gender: \"male\",\r\n        accent: \"american\",\r\n        category: \"announcement\",\r\n        provider: \"azure\"\r\n      }\r\n    ]\r\n  }\r\n\r\n  private mapAzureVoices(voices: any[]): AIVoiceProfile[] {\r\n    return voices\r\n      .filter(voice => voice.VoiceType === \"Neural\") // Only use neural voices\r\n      .map(voice => ({\r\n        id: `azure-${voice.ShortName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`,\r\n        name: voice.DisplayName,\r\n        language: this.mapLocaleToLanguage(voice.Locale),\r\n        gender: voice.Gender.toLowerCase() as \"male\" | \"female\" | \"neutral\",\r\n        accent: this.extractAccent(voice.LocaleName),\r\n        category: this.categorizeVoice(voice.StyleList || []),\r\n        provider: \"azure\"\r\n      }))\r\n      .slice(0, 20) // Limit to first 20 voices to avoid overwhelming UI\r\n  }\r\n\r\n  private mapLocaleToLanguage(locale: string): string {\r\n    const languageMap: Record<string, string> = {\r\n      \"en-US\": \"english\",\r\n      \"en-GB\": \"english\",\r\n      \"en-AU\": \"english\",\r\n      \"en-CA\": \"english\",\r\n      \"es-ES\": \"spanish\",\r\n      \"es-MX\": \"spanish\",\r\n      \"fr-FR\": \"french\",\r\n      \"fr-CA\": \"french\",\r\n      \"de-DE\": \"german\",\r\n      \"it-IT\": \"italian\",\r\n      \"pt-BR\": \"portuguese\",\r\n      \"pt-PT\": \"portuguese\",\r\n      \"ru-RU\": \"russian\",\r\n      \"ja-JP\": \"japanese\",\r\n      \"ko-KR\": \"korean\",\r\n      \"zh-CN\": \"chinese\",\r\n      \"ar-SA\": \"arabic\",\r\n      \"hi-IN\": \"hindi\",\r\n      \"nl-NL\": \"dutch\",\r\n      \"sv-SE\": \"swedish\"\r\n    }\r\n    \r\n    return languageMap[locale] || \"english\"\r\n  }\r\n\r\n  private extractAccent(localeName: string): string | undefined {\r\n    if (localeName.includes(\"United States\")) return \"american\"\r\n    if (localeName.includes(\"United Kingdom\")) return \"british\"\r\n    if (localeName.includes(\"Australia\")) return \"australian\"\r\n    if (localeName.includes(\"Canada\")) return \"canadian\"\r\n    return undefined\r\n  }\r\n\r\n  private categorizeVoice(styleList: string[]): \"standard\" | \"religious\" | \"announcement\" | \"bell\" {\r\n    const styles = styleList.join(\" \").toLowerCase()\r\n    \r\n    if (styles.includes(\"newscast\") || styles.includes(\"announcement\")) {\r\n      return \"announcement\"\r\n    }\r\n    if (styles.includes(\"religious\") || styles.includes(\"prayer\")) {\r\n      return \"religious\"\r\n    }\r\n    return \"standard\"\r\n  }\r\n\r\n  private mapVoiceId(voiceId: string): { name: string; locale: string } {\r\n    // Map our voice IDs to Azure voice names\r\n    const voiceMap: Record<string, { name: string; locale: string }> = {\r\n      \"azure-jenny\": { name: \"en-US-JennyNeural\", locale: \"en-US\" },\r\n      \"azure-guy\": { name: \"en-US-GuyNeural\", locale: \"en-US\" },\r\n      \"azure-aria\": { name: \"en-US-AriaNeural\", locale: \"en-US\" },\r\n      \"azure-davis\": { name: \"en-US-DavisNeural\", locale: \"en-US\" },\r\n      \"azure-jane\": { name: \"en-US-JaneNeural\", locale: \"en-US\" },\r\n      \"azure-jason\": { name: \"en-US-JasonNeural\", locale: \"en-US\" }\r\n    }\r\n\r\n    return voiceMap[voiceId] || { name: \"en-US-JennyNeural\", locale: \"en-US\" }\r\n  }\r\n\r\n  private async handleErrorResponse(response: Response): Promise<never> {\r\n    const errorText = await response.text()\r\n    let errorData: any = {}\r\n    \r\n    try {\r\n      errorData = JSON.parse(errorText)\r\n    } catch {\r\n      // If JSON parsing fails, use the raw text\r\n    }\r\n\r\n    switch (response.status) {\r\n      case 401:\r\n      case 403:\r\n        throw new AuthenticationError(\"Azure\")\r\n      case 429:\r\n        const retryAfter = response.headers.get(\"retry-after\")\r\n        throw new RateLimitError(\"Azure\", retryAfter ? parseInt(retryAfter) : undefined)\r\n      case 500:\r\n      case 502:\r\n      case 503:\r\n      case 504:\r\n        throw new ServiceUnavailableError(\"Azure\")\r\n      default:\r\n        throw new AIVoiceError(\r\n          errorData.error?.message || `Azure API error: ${response.status}`,\r\n          \"Azure\",\r\n          `HTTP_${response.status}`,\r\n          response.status >= 500\r\n        )\r\n    }\r\n  }\r\n\r\n  private async convertMp3ToAudioBuffer(mp3ArrayBuffer: ArrayBuffer): Promise<AudioBuffer> {\r\n    // Create AudioContext\r\n    const AudioContext = window.AudioContext || (window as any).webkitAudioContext\r\n    const audioContext = new AudioContext()\r\n\r\n    try {\r\n      // Decode the MP3 data\r\n      const audioBuffer = await audioContext.decodeAudioData(mp3ArrayBuffer.slice(0))\r\n      return audioBuffer\r\n    } catch (error) {\r\n      throw new AIVoiceError(\r\n        \"Failed to decode audio data from Azure\",\r\n        \"Azure\",\r\n        \"DECODE_ERROR\",\r\n        false\r\n      )\r\n    }\r\n  }\r\n\r\n  // Utility method to check if a language is supported\r\n  isLanguageSupported(language: string): boolean {\r\n    const supportedLanguages = [\r\n      \"english\", \"spanish\", \"french\", \"german\", \"italian\", \"portuguese\", \r\n      \"russian\", \"japanese\", \"korean\", \"chinese\", \"arabic\", \"hindi\", \r\n      \"dutch\", \"swedish\", \"norwegian\", \"danish\", \"finnish\"\r\n    ]\r\n    return supportedLanguages.includes(language.toLowerCase())\r\n  }\r\n\r\n  // Get the maximum character limit for Azure\r\n  getMaxCharacters(): number {\r\n    return 10000\r\n  }\r\n\r\n  // Get supported audio formats\r\n  getSupportedFormats(): string[] {\r\n    return [\"mp3\", \"wav\", \"ogg\", \"webm\"]\r\n  }\r\n\r\n  // Update API key and region\r\n  updateCredentials(apiKey: string, endpoint?: string): void {\r\n    this.apiKey = apiKey\r\n    \r\n    if (endpoint) {\r\n      const match = endpoint.match(/https:\\/\\/([^.]+)\\.tts\\.speech\\.microsoft\\.com/)\r\n      this.region = match ? match[1] : \"eastus\"\r\n      this.baseUrl = endpoint\r\n    }\r\n  }\r\n\r\n  // Get current API key (masked for security)\r\n  getApiKeyMask(): string {\r\n    if (!this.apiKey) return \"\"\r\n    return this.apiKey.substring(0, 7) + \"...\" + this.apiKey.substring(this.apiKey.length - 4)\r\n  }\r\n\r\n  // Get current region\r\n  getRegion(): string {\r\n    return this.region\r\n  }\r\n\r\n  // Azure specific methods\r\n  async getVoiceStyles(voiceName: string): Promise<string[]> {\r\n    // This would require additional API calls to get voice styles\r\n    // For now, return common styles\r\n    return [\"default\", \"newscast\", \"customerservice\", \"chat\", \"cheerful\", \"empathetic\"]\r\n  }\r\n\r\n  async getSpeechSynthesisMarkup(text: string, voiceName: string, options?: {\r\n    rate?: string\r\n    pitch?: string\r\n    volume?: string\r\n    style?: string\r\n  }): Promise<string> {\r\n    const rate = options?.rate || \"medium\"\r\n    const pitch = options?.pitch || \"medium\"\r\n    const volume = options?.volume || \"medium\"\r\n    const style = options?.style || \"default\"\r\n    \r\n    return `\r\n      <speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xml:lang=\"en-US\">\r\n        <voice name=\"${voiceName}\">\r\n          <mstts:express-as style=\"${style}\">\r\n            <prosody rate=\"${rate}\" pitch=\"${pitch}\" volume=\"${volume}\">\r\n              ${this.escapeXML(text)}\r\n            </prosody>\r\n          </mstts:express-as>\r\n        </voice>\r\n      </speak>\r\n    `.trim()\r\n  }\r\n}","import type { AIVoiceProvider, ProviderConfig, AIVoiceProviderType } from \"../ai-voice-types\"\r\nimport { OpenAIProvider } from \"./openai-provider\"\r\nimport { ElevenLabsProvider } from \"./elevenlabs-provider\"\r\nimport { AzureProvider } from \"./azure-provider\"\r\n\r\nexport class ProviderFactory {\r\n  private static providers: Map<string, AIVoiceProvider> = new Map()\r\n\r\n  static createProvider(\r\n    type: AIVoiceProviderType,\r\n    config: ProviderConfig\r\n  ): AIVoiceProvider {\r\n    const key = `${type}-${config.apiKey.substring(0, 8)}`\r\n    \r\n    // Return existing provider if already created with same config\r\n    if (this.providers.has(key)) {\r\n      const existingProvider = this.providers.get(key)!\r\n      return existingProvider\r\n    }\r\n\r\n    let provider: AIVoiceProvider\r\n\r\n    switch (type) {\r\n      case \"openai\":\r\n        provider = new OpenAIProvider(config.apiKey)\r\n        break\r\n      case \"elevenlabs\":\r\n        provider = new ElevenLabsProvider(config.apiKey)\r\n        break\r\n      case \"azure\":\r\n        provider = new AzureProvider(config.apiKey, config.endpoint)\r\n        break\r\n      default:\r\n        throw new Error(`Unknown provider type: ${type}`)\r\n    }\r\n\r\n    this.providers.set(key, provider)\r\n    return provider\r\n  }\r\n\r\n  static getProvider(\r\n    type: AIVoiceProviderType,\r\n    config: ProviderConfig\r\n  ): AIVoiceProvider | null {\r\n    const key = `${type}-${config.apiKey.substring(0, 8)}`\r\n    return this.providers.get(key) || null\r\n  }\r\n\r\n  static removeProvider(\r\n    type: AIVoiceProviderType,\r\n    config: ProviderConfig\r\n  ): void {\r\n    const key = `${type}-${config.apiKey.substring(0, 8)}`\r\n    this.providers.delete(key)\r\n  }\r\n\r\n  static clearAllProviders(): void {\r\n    this.providers.clear()\r\n  }\r\n\r\n  static getActiveProviders(): Array<{\r\n    type: AIVoiceProviderType\r\n    provider: AIVoiceProvider\r\n  }> {\r\n    const activeProviders: Array<{\r\n      type: AIVoiceProviderType\r\n      provider: AIVoiceProvider\r\n    }> = []\r\n\r\n    for (const [key, provider] of this.providers.entries()) {\r\n      const type = key.split(\"-\")[0] as AIVoiceProviderType\r\n      activeProviders.push({ type, provider })\r\n    }\r\n\r\n    return activeProviders\r\n  }\r\n\r\n  static async validateAllProviders(): Promise<Record<string, boolean>> {\r\n    const results: Record<string, boolean> = {}\r\n\r\n    for (const [key, provider] of this.providers.entries()) {\r\n      try {\r\n        results[key] = await provider.validateCredentials()\r\n      } catch (error) {\r\n        results[key] = false\r\n      }\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n  static getSupportedProviders(): AIVoiceProviderType[] {\r\n    return [\"openai\", \"elevenlabs\", \"azure\"]\r\n  }\r\n\r\n  static isProviderSupported(type: AIVoiceProviderType): boolean {\r\n    return this.getSupportedProviders().includes(type)\r\n  }\r\n}\r\n\r\n// Utility function to create provider with error handling\r\nexport const createProviderSafely = async (\r\n  type: AIVoiceProviderType,\r\n  config: ProviderConfig\r\n): Promise<{\r\n  provider: AIVoiceProvider | null\r\n  error: string | null\r\n}> => {\r\n  try {\r\n    if (!ProviderFactory.isProviderSupported(type)) {\r\n      return {\r\n        provider: null,\r\n        error: `Provider ${type} is not yet supported`\r\n      }\r\n    }\r\n\r\n    const provider = ProviderFactory.createProvider(type, config)\r\n    \r\n    // Validate credentials\r\n    const isValid = await provider.validateCredentials()\r\n    if (!isValid) {\r\n      return {\r\n        provider: null,\r\n        error: `Invalid credentials for ${type} provider`\r\n      }\r\n    }\r\n\r\n    return {\r\n      provider,\r\n      error: null\r\n    }\r\n  } catch (error) {\r\n    return {\r\n      provider: null,\r\n      error: error instanceof Error ? error.message : `Failed to create ${type} provider`\r\n    }\r\n  }\r\n}","import type { AudioCacheManager, CacheMetadata, CacheStats } from \"./ai-voice-types\"\r\nimport { generateCacheKey } from \"./ai-voice-constants\"\r\n\r\n// IndexedDB database configuration\r\nconst DB_NAME = \"AIVoiceCache\"\r\nconst DB_VERSION = 1\r\nconst AUDIO_STORE = \"audioFiles\"\r\nconst METADATA_STORE = \"metadata\"\r\n\r\ninterface StoredAudioData {\r\n  key: string\r\n  audioBuffer: ArrayBuffer\r\n  metadata: CacheMetadata\r\n}\r\n\r\ninterface StoredMetadata extends CacheMetadata {\r\n  key: string\r\n}\r\n\r\nexport class IndexedDBAudioCache implements AudioCacheManager {\r\n  private db: IDBDatabase | null = null\r\n  private initPromise: Promise<void> | null = null\r\n\r\n  constructor() {\r\n    this.initPromise = this.initializeDB()\r\n  }\r\n\r\n  private async initializeDB(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (typeof window === \"undefined\" || !window.indexedDB) {\r\n        reject(new Error(\"IndexedDB not available\"))\r\n        return\r\n      }\r\n\r\n      const request = indexedDB.open(DB_NAME, DB_VERSION)\r\n\r\n      request.onerror = () => {\r\n        reject(new Error(\"Failed to open IndexedDB\"))\r\n      }\r\n\r\n      request.onsuccess = () => {\r\n        this.db = request.result\r\n        resolve()\r\n      }\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        const db = (event.target as IDBOpenDBRequest).result\r\n\r\n        // Create audio files store\r\n        if (!db.objectStoreNames.contains(AUDIO_STORE)) {\r\n          const audioStore = db.createObjectStore(AUDIO_STORE, { keyPath: \"key\" })\r\n          audioStore.createIndex(\"timestamp\", \"metadata.timestamp\", { unique: false })\r\n          audioStore.createIndex(\"provider\", \"metadata.provider\", { unique: false })\r\n          audioStore.createIndex(\"usage\", \"metadata.usage\", { unique: false })\r\n        }\r\n\r\n        // Create metadata store for quick queries\r\n        if (!db.objectStoreNames.contains(METADATA_STORE)) {\r\n          const metadataStore = db.createObjectStore(METADATA_STORE, { keyPath: \"key\" })\r\n          metadataStore.createIndex(\"timestamp\", \"timestamp\", { unique: false })\r\n          metadataStore.createIndex(\"provider\", \"provider\", { unique: false })\r\n          metadataStore.createIndex(\"size\", \"size\", { unique: false })\r\n          metadataStore.createIndex(\"usage\", \"usage\", { unique: false })\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  private async ensureDB(): Promise<IDBDatabase> {\r\n    if (!this.initPromise) {\r\n      this.initPromise = this.initializeDB()\r\n    }\r\n    await this.initPromise\r\n\r\n    if (!this.db) {\r\n      throw new Error(\"Database not initialized\")\r\n    }\r\n    return this.db\r\n  }\r\n\r\n  async store(key: string, audio: AudioBuffer, metadata: CacheMetadata): Promise<void> {\r\n    const db = await this.ensureDB()\r\n\r\n    // Convert AudioBuffer to ArrayBuffer for storage\r\n    const arrayBuffer = this.audioBufferToArrayBuffer(audio)\r\n\r\n    const audioData: StoredAudioData = {\r\n      key,\r\n      audioBuffer: arrayBuffer,\r\n      metadata: {\r\n        ...metadata,\r\n        timestamp: Date.now(),\r\n        size: arrayBuffer.byteLength\r\n      }\r\n    }\r\n\r\n    const metadataRecord: StoredMetadata = {\r\n      key,\r\n      ...audioData.metadata\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([AUDIO_STORE, METADATA_STORE], \"readwrite\")\r\n      \r\n      transaction.onerror = () => {\r\n        reject(new Error(\"Failed to store audio data\"))\r\n      }\r\n\r\n      transaction.oncomplete = () => {\r\n        resolve()\r\n      }\r\n\r\n      // Store audio data\r\n      const audioStore = transaction.objectStore(AUDIO_STORE)\r\n      audioStore.put(audioData)\r\n\r\n      // Store metadata separately for quick queries\r\n      const metadataStore = transaction.objectStore(METADATA_STORE)\r\n      metadataStore.put(metadataRecord)\r\n    })\r\n  }\r\n\r\n  async retrieve(key: string): Promise<AudioBuffer | null> {\r\n    const db = await this.ensureDB()\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([AUDIO_STORE, METADATA_STORE], \"readwrite\")\r\n      const audioStore = transaction.objectStore(AUDIO_STORE)\r\n      const metadataStore = transaction.objectStore(METADATA_STORE)\r\n\r\n      const request = audioStore.get(key)\r\n\r\n      request.onerror = () => {\r\n        reject(new Error(\"Failed to retrieve audio data\"))\r\n      }\r\n\r\n      request.onsuccess = () => {\r\n        const result = request.result as StoredAudioData | undefined\r\n\r\n        if (!result) {\r\n          resolve(null)\r\n          return\r\n        }\r\n\r\n        try {\r\n          // Convert ArrayBuffer back to AudioBuffer\r\n          const audioBuffer = this.arrayBufferToAudioBuffer(result.audioBuffer)\r\n          \r\n          // Update usage count\r\n          const updateRequest = metadataStore.get(key)\r\n          updateRequest.onsuccess = () => {\r\n            const metadata = updateRequest.result as StoredMetadata\r\n            if (metadata) {\r\n              metadata.usage += 1\r\n              metadataStore.put(metadata)\r\n              \r\n              // Also update in audio store\r\n              result.metadata.usage += 1\r\n              audioStore.put(result)\r\n            }\r\n          }\r\n\r\n          resolve(audioBuffer)\r\n        } catch (error) {\r\n          reject(new Error(\"Failed to convert stored data to AudioBuffer\"))\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  async exists(key: string): Promise<boolean> {\r\n    const db = await this.ensureDB()\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction(METADATA_STORE, \"readonly\")\r\n      const store = transaction.objectStore(METADATA_STORE)\r\n      const request = store.count(key)\r\n\r\n      request.onerror = () => {\r\n        reject(new Error(\"Failed to check if key exists\"))\r\n      }\r\n\r\n      request.onsuccess = () => {\r\n        resolve(request.result > 0)\r\n      }\r\n    })\r\n  }\r\n\r\n  async clear(pattern?: string): Promise<void> {\r\n    const db = await this.ensureDB()\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([AUDIO_STORE, METADATA_STORE], \"readwrite\")\r\n      \r\n      transaction.onerror = () => {\r\n        reject(new Error(\"Failed to clear cache\"))\r\n      }\r\n\r\n      transaction.oncomplete = () => {\r\n        resolve()\r\n      }\r\n\r\n      if (!pattern) {\r\n        // Clear all data\r\n        transaction.objectStore(AUDIO_STORE).clear()\r\n        transaction.objectStore(METADATA_STORE).clear()\r\n      } else {\r\n        // Clear data matching pattern\r\n        this.clearByPattern(transaction, pattern)\r\n      }\r\n    })\r\n  }\r\n\r\n  private clearByPattern(transaction: IDBTransaction, pattern: string): void {\r\n    const metadataStore = transaction.objectStore(METADATA_STORE)\r\n    const audioStore = transaction.objectStore(AUDIO_STORE)\r\n    \r\n    const request = metadataStore.openCursor()\r\n    \r\n    request.onsuccess = (event) => {\r\n      const cursor = (event.target as IDBRequest).result as IDBCursorWithValue\r\n      \r\n      if (cursor) {\r\n        const metadata = cursor.value as StoredMetadata\r\n        \r\n        // Simple pattern matching - check if key contains pattern\r\n        if (metadata.key.includes(pattern) || \r\n            metadata.provider.includes(pattern) ||\r\n            metadata.voice.includes(pattern)) {\r\n          \r\n          // Delete from both stores\r\n          audioStore.delete(metadata.key)\r\n          metadataStore.delete(metadata.key)\r\n        }\r\n        \r\n        cursor.continue()\r\n      }\r\n    }\r\n  }\r\n\r\n  async getUsageStats(): Promise<CacheStats> {\r\n    const db = await this.ensureDB()\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction(METADATA_STORE, \"readonly\")\r\n      const store = transaction.objectStore(METADATA_STORE)\r\n      const request = store.openCursor()\r\n\r\n      let totalSize = 0\r\n      let totalFiles = 0\r\n      let totalUsage = 0\r\n      let oldestFile = Date.now()\r\n      let newestFile = 0\r\n\r\n      request.onerror = () => {\r\n        reject(new Error(\"Failed to get usage stats\"))\r\n      }\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = (event.target as IDBRequest).result as IDBCursorWithValue\r\n\r\n        if (cursor) {\r\n          const metadata = cursor.value as StoredMetadata\r\n          \r\n          totalSize += metadata.size\r\n          totalFiles += 1\r\n          totalUsage += metadata.usage\r\n          \r\n          if (metadata.timestamp < oldestFile) {\r\n            oldestFile = metadata.timestamp\r\n          }\r\n          \r\n          if (metadata.timestamp > newestFile) {\r\n            newestFile = metadata.timestamp\r\n          }\r\n\r\n          cursor.continue()\r\n        } else {\r\n          // Calculate hit rate (simplified - based on average usage)\r\n          const hitRate = totalFiles > 0 ? (totalUsage / totalFiles) * 100 : 0\r\n\r\n          resolve({\r\n            totalSize,\r\n            totalFiles,\r\n            hitRate: Math.min(hitRate, 100), // Cap at 100%\r\n            oldestFile: totalFiles > 0 ? oldestFile : 0,\r\n            newestFile: totalFiles > 0 ? newestFile : 0\r\n          })\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  async cleanup(): Promise<void> {\r\n    const stats = await this.getUsageStats()\r\n    const maxSize = 100 * 1024 * 1024 // 100MB default\r\n    const maxAge = 30 * 24 * 60 * 60 * 1000 // 30 days in milliseconds\r\n\r\n    if (stats.totalSize <= maxSize) {\r\n      // Only clean up old files if not over size limit\r\n      await this.cleanupOldFiles(maxAge)\r\n      return\r\n    }\r\n\r\n    // If over size limit, clean up least used files first\r\n    await this.cleanupLeastUsedFiles(maxSize)\r\n  }\r\n\r\n  private async cleanupOldFiles(maxAge: number): Promise<void> {\r\n    const db = await this.ensureDB()\r\n    const cutoffTime = Date.now() - maxAge\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([AUDIO_STORE, METADATA_STORE], \"readwrite\")\r\n      \r\n      transaction.onerror = () => {\r\n        reject(new Error(\"Failed to cleanup old files\"))\r\n      }\r\n\r\n      transaction.oncomplete = () => {\r\n        resolve()\r\n      }\r\n\r\n      const metadataStore = transaction.objectStore(METADATA_STORE)\r\n      const audioStore = transaction.objectStore(AUDIO_STORE)\r\n      const index = metadataStore.index(\"timestamp\")\r\n      \r\n      const request = index.openCursor(IDBKeyRange.upperBound(cutoffTime))\r\n      \r\n      request.onsuccess = (event) => {\r\n        const cursor = (event.target as IDBRequest).result as IDBCursorWithValue\r\n        \r\n        if (cursor) {\r\n          const metadata = cursor.value as StoredMetadata\r\n          \r\n          // Delete old files\r\n          audioStore.delete(metadata.key)\r\n          metadataStore.delete(metadata.key)\r\n          \r\n          cursor.continue()\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  private async cleanupLeastUsedFiles(maxSize: number): Promise<void> {\r\n    const db = await this.ensureDB()\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([AUDIO_STORE, METADATA_STORE], \"readwrite\")\r\n      \r\n      transaction.onerror = () => {\r\n        reject(new Error(\"Failed to cleanup least used files\"))\r\n      }\r\n\r\n      transaction.oncomplete = () => {\r\n        resolve()\r\n      }\r\n\r\n      const metadataStore = transaction.objectStore(METADATA_STORE)\r\n      const audioStore = transaction.objectStore(AUDIO_STORE)\r\n      const index = metadataStore.index(\"usage\")\r\n      \r\n      let currentSize = 0\r\n      const request = index.openCursor() // Opens in ascending order (least used first)\r\n      \r\n      request.onsuccess = (event) => {\r\n        const cursor = (event.target as IDBRequest).result as IDBCursorWithValue\r\n        \r\n        if (cursor && currentSize < maxSize) {\r\n          const metadata = cursor.value as StoredMetadata\r\n          currentSize += metadata.size\r\n          \r\n          if (currentSize > maxSize) {\r\n            // Delete this file to get under the limit\r\n            audioStore.delete(metadata.key)\r\n            metadataStore.delete(metadata.key)\r\n          }\r\n          \r\n          cursor.continue()\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  // Utility methods for AudioBuffer conversion\r\n  private audioBufferToArrayBuffer(audioBuffer: AudioBuffer): ArrayBuffer {\r\n    const numberOfChannels = audioBuffer.numberOfChannels\r\n    const length = audioBuffer.length\r\n    const sampleRate = audioBuffer.sampleRate\r\n\r\n    // Create a simple format: [numberOfChannels, length, sampleRate, ...channelData]\r\n    const headerSize = 3 * 4 // 3 32-bit integers\r\n    const dataSize = numberOfChannels * length * 4 // 32-bit floats\r\n    const arrayBuffer = new ArrayBuffer(headerSize + dataSize)\r\n    \r\n    const headerView = new Int32Array(arrayBuffer, 0, 3)\r\n    headerView[0] = numberOfChannels\r\n    headerView[1] = length\r\n    headerView[2] = sampleRate\r\n\r\n    let offset = headerSize\r\n    for (let channel = 0; channel < numberOfChannels; channel++) {\r\n      const channelData = audioBuffer.getChannelData(channel)\r\n      const channelView = new Float32Array(arrayBuffer, offset, length)\r\n      channelView.set(channelData)\r\n      offset += length * 4\r\n    }\r\n\r\n    return arrayBuffer\r\n  }\r\n\r\n  private arrayBufferToAudioBuffer(arrayBuffer: ArrayBuffer): AudioBuffer {\r\n    const headerView = new Int32Array(arrayBuffer, 0, 3)\r\n    const numberOfChannels = headerView[0]\r\n    const length = headerView[1]\r\n    const sampleRate = headerView[2]\r\n\r\n    // Create AudioContext if not available (for Node.js environments)\r\n    const AudioContext = window.AudioContext || (window as any).webkitAudioContext\r\n    const audioContext = new AudioContext()\r\n    \r\n    const audioBuffer = audioContext.createBuffer(numberOfChannels, length, sampleRate)\r\n\r\n    let offset = 3 * 4 // Skip header\r\n    for (let channel = 0; channel < numberOfChannels; channel++) {\r\n      const channelView = new Float32Array(arrayBuffer, offset, length)\r\n      const channelData = audioBuffer.getChannelData(channel)\r\n      channelData.set(channelView)\r\n      offset += length * 4\r\n    }\r\n\r\n    return audioBuffer\r\n  }\r\n}\r\n\r\n// Factory function to create cache instance\r\nexport const createAudioCache = (): AudioCacheManager => {\r\n  return new IndexedDBAudioCache()\r\n}\r\n\r\n// Singleton instance for global use\r\nlet cacheInstance: AudioCacheManager | null = null\r\n\r\nexport const getAudioCache = (): AudioCacheManager => {\r\n  if (!cacheInstance) {\r\n    cacheInstance = createAudioCache()\r\n  }\r\n  return cacheInstance\r\n}","import type { AudioCacheManager, CacheMetadata, CacheStats, AIVoiceSettings } from \"./ai-voice-types\"\r\nimport { getAudioCache } from \"./audio-cache\"\r\nimport { generateCacheKey } from \"./ai-voice-constants\"\r\n\r\nexport class CacheManager {\r\n  private cache: AudioCacheManager\r\n  private settings: AIVoiceSettings | null = null\r\n\r\n  constructor(cache?: AudioCacheManager) {\r\n    this.cache = cache || getAudioCache()\r\n  }\r\n\r\n  updateSettings(settings: AIVoiceSettings): void {\r\n    this.settings = settings\r\n  }\r\n\r\n  async storeAudio(\r\n    text: string,\r\n    voice: string,\r\n    provider: string,\r\n    audioBuffer: AudioBuffer\r\n  ): Promise<void> {\r\n    if (!this.settings?.cacheSettings.enabled) {\r\n      return\r\n    }\r\n\r\n    const key = generateCacheKey(text, voice, provider)\r\n    const metadata: CacheMetadata = {\r\n      text: text.substring(0, 100), // Store first 100 chars for reference\r\n      voice,\r\n      provider,\r\n      timestamp: Date.now(),\r\n      size: this.estimateAudioBufferSize(audioBuffer),\r\n      usage: 0\r\n    }\r\n\r\n    await this.cache.store(key, audioBuffer, metadata)\r\n    \r\n    // Check if cleanup is needed after storing\r\n    await this.performMaintenanceIfNeeded()\r\n  }\r\n\r\n  async retrieveAudio(\r\n    text: string,\r\n    voice: string,\r\n    provider: string\r\n  ): Promise<AudioBuffer | null> {\r\n    if (!this.settings?.cacheSettings.enabled) {\r\n      return null\r\n    }\r\n\r\n    const key = generateCacheKey(text, voice, provider)\r\n    return await this.cache.retrieve(key)\r\n  }\r\n\r\n  async hasAudio(\r\n    text: string,\r\n    voice: string,\r\n    provider: string\r\n  ): Promise<boolean> {\r\n    if (!this.settings?.cacheSettings.enabled) {\r\n      return false\r\n    }\r\n\r\n    const key = generateCacheKey(text, voice, provider)\r\n    return await this.cache.exists(key)\r\n  }\r\n\r\n  async clearProviderCache(provider: string): Promise<void> {\r\n    await this.cache.clear(provider)\r\n  }\r\n\r\n  async clearVoiceCache(voice: string): Promise<void> {\r\n    await this.cache.clear(voice)\r\n  }\r\n\r\n  async clearAllCache(): Promise<void> {\r\n    await this.cache.clear()\r\n  }\r\n\r\n  async getCacheStats(): Promise<CacheStats> {\r\n    return await this.cache.getUsageStats()\r\n  }\r\n\r\n  async getCacheHealth(): Promise<{\r\n    healthy: boolean\r\n    issues: string[]\r\n    recommendations: string[]\r\n  }> {\r\n    const stats = await this.getCacheStats()\r\n    const issues: string[] = []\r\n    const recommendations: string[] = []\r\n    \r\n    const maxSize = (this.settings?.cacheSettings.maxSize || 100) * 1024 * 1024 // Convert MB to bytes\r\n    const maxAge = (this.settings?.cacheSettings.maxAge || 30) * 24 * 60 * 60 * 1000 // Convert days to ms\r\n\r\n    // Check size\r\n    if (stats.totalSize > maxSize * 0.9) {\r\n      issues.push(\"Cache is approaching size limit\")\r\n      recommendations.push(\"Consider increasing cache size or cleaning up old files\")\r\n    }\r\n\r\n    // Check age of oldest files\r\n    const oldestAge = Date.now() - stats.oldestFile\r\n    if (oldestAge > maxAge) {\r\n      issues.push(\"Cache contains very old files\")\r\n      recommendations.push(\"Run cache cleanup to remove expired files\")\r\n    }\r\n\r\n    // Check hit rate\r\n    if (stats.hitRate < 20) {\r\n      issues.push(\"Low cache hit rate\")\r\n      recommendations.push(\"Consider adjusting voice generation patterns or cache settings\")\r\n    }\r\n\r\n    // Check file count\r\n    if (stats.totalFiles > 1000) {\r\n      issues.push(\"Large number of cached files\")\r\n      recommendations.push(\"Consider more aggressive cleanup policies\")\r\n    }\r\n\r\n    return {\r\n      healthy: issues.length === 0,\r\n      issues,\r\n      recommendations\r\n    }\r\n  }\r\n\r\n  async performMaintenance(): Promise<{\r\n    filesRemoved: number\r\n    spaceSaved: number\r\n    errors: string[]\r\n  }> {\r\n    const beforeStats = await this.getCacheStats()\r\n    const errors: string[] = []\r\n\r\n    try {\r\n      await this.cache.cleanup()\r\n    } catch (error) {\r\n      errors.push(`Cleanup failed: ${error instanceof Error ? error.message : 'Unknown error'}`)\r\n    }\r\n\r\n    const afterStats = await this.getCacheStats()\r\n    \r\n    return {\r\n      filesRemoved: beforeStats.totalFiles - afterStats.totalFiles,\r\n      spaceSaved: beforeStats.totalSize - afterStats.totalSize,\r\n      errors\r\n    }\r\n  }\r\n\r\n  private async performMaintenanceIfNeeded(): Promise<void> {\r\n    if (!this.settings) return\r\n\r\n    const stats = await this.getCacheStats()\r\n    const maxSize = this.settings.cacheSettings.maxSize * 1024 * 1024 // Convert MB to bytes\r\n\r\n    // Perform maintenance if over 90% of max size\r\n    if (stats.totalSize > maxSize * 0.9) {\r\n      try {\r\n        await this.cache.cleanup()\r\n      } catch (error) {\r\n        console.warn(\"Cache maintenance failed:\", error)\r\n      }\r\n    }\r\n  }\r\n\r\n  private estimateAudioBufferSize(audioBuffer: AudioBuffer): number {\r\n    // Estimate size: numberOfChannels * length * 4 bytes per sample + overhead\r\n    return audioBuffer.numberOfChannels * audioBuffer.length * 4 + 100\r\n  }\r\n\r\n  // Utility methods for cache optimization\r\n  async getTopUsedVoices(limit: number = 10): Promise<Array<{\r\n    voice: string\r\n    provider: string\r\n    usage: number\r\n    size: number\r\n  }>> {\r\n    // This would require extending the cache interface to support more complex queries\r\n    // For now, return empty array - can be implemented later if needed\r\n    return []\r\n  }\r\n\r\n  async getCacheUsageByProvider(): Promise<Record<string, {\r\n    files: number\r\n    size: number\r\n    usage: number\r\n  }>> {\r\n    // This would require extending the cache interface to support aggregation queries\r\n    // For now, return empty object - can be implemented later if needed\r\n    return {}\r\n  }\r\n\r\n  async optimizeCache(): Promise<{\r\n    duplicatesRemoved: number\r\n    spaceSaved: number\r\n    optimizationApplied: string[]\r\n  }> {\r\n    const optimizationApplied: string[] = []\r\n    let duplicatesRemoved = 0\r\n    let spaceSaved = 0\r\n\r\n    // Future optimization strategies:\r\n    // 1. Remove duplicate content with different keys\r\n    // 2. Compress old audio files\r\n    // 3. Convert to more efficient formats\r\n    // 4. Merge similar content\r\n\r\n    optimizationApplied.push(\"Basic cleanup performed\")\r\n\r\n    try {\r\n      const maintenanceResult = await this.performMaintenance()\r\n      spaceSaved = maintenanceResult.spaceSaved\r\n      optimizationApplied.push(\"Expired files removed\")\r\n    } catch (error) {\r\n      console.warn(\"Cache optimization failed:\", error)\r\n    }\r\n\r\n    return {\r\n      duplicatesRemoved,\r\n      spaceSaved,\r\n      optimizationApplied\r\n    }\r\n  }\r\n}\r\n\r\n// Global cache manager instance\r\nlet cacheManagerInstance: CacheManager | null = null\r\n\r\nexport const getCacheManager = (): CacheManager => {\r\n  if (!cacheManagerInstance) {\r\n    cacheManagerInstance = new CacheManager()\r\n  }\r\n  return cacheManagerInstance\r\n}\r\n\r\nexport const initializeCacheManager = (settings: AIVoiceSettings): CacheManager => {\r\n  const manager = getCacheManager()\r\n  manager.updateSettings(settings)\r\n  return manager\r\n}","import type { AIVoiceProviderType, ProviderConfig, AudioGenerationRequest } from \"./ai-voice-types\"\r\n\r\ninterface RateLimitState {\r\n  requests: number[]\r\n  characters: number[]\r\n  lastReset: number\r\n}\r\n\r\ninterface QueuedRequest {\r\n  id: string\r\n  request: AudioGenerationRequest\r\n  resolve: (value: any) => void\r\n  reject: (error: any) => void\r\n  timestamp: number\r\n  retryCount: number\r\n}\r\n\r\nexport class RateLimiter {\r\n  private limits: Map<AIVoiceProviderType, ProviderConfig['rateLimit']> = new Map()\r\n  private state: Map<AIVoiceProviderType, RateLimitState> = new Map()\r\n  private queues: Map<AIVoiceProviderType, QueuedRequest[]> = new Map()\r\n  private processing: Map<AIVoiceProviderType, boolean> = new Map()\r\n  \r\n  private readonly MINUTE_MS = 60 * 1000\r\n  private readonly DAY_MS = 24 * 60 * 60 * 1000\r\n  private readonly MAX_QUEUE_SIZE = 100\r\n  private readonly MAX_RETRY_COUNT = 3\r\n  private readonly RETRY_DELAY_BASE = 1000 // 1 second\r\n\r\n  constructor() {\r\n    // Start queue processing\r\n    this.startQueueProcessor()\r\n  }\r\n\r\n  updateProviderLimits(provider: AIVoiceProviderType, limits: ProviderConfig['rateLimit']): void {\r\n    this.limits.set(provider, limits)\r\n    \r\n    if (!this.state.has(provider)) {\r\n      this.state.set(provider, {\r\n        requests: [],\r\n        characters: [],\r\n        lastReset: Date.now()\r\n      })\r\n    }\r\n    \r\n    if (!this.queues.has(provider)) {\r\n      this.queues.set(provider, [])\r\n    }\r\n    \r\n    if (!this.processing.has(provider)) {\r\n      this.processing.set(provider, false)\r\n    }\r\n  }\r\n\r\n  async executeWithRateLimit<T>(\r\n    provider: AIVoiceProviderType,\r\n    request: AudioGenerationRequest,\r\n    executor: () => Promise<T>\r\n  ): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      const queuedRequest: QueuedRequest = {\r\n        id: request.id,\r\n        request,\r\n        resolve,\r\n        reject,\r\n        timestamp: Date.now(),\r\n        retryCount: 0\r\n      }\r\n\r\n      this.enqueueRequest(provider, queuedRequest, executor)\r\n    })\r\n  }\r\n\r\n  private enqueueRequest<T>(\r\n    provider: AIVoiceProviderType,\r\n    queuedRequest: QueuedRequest,\r\n    executor: () => Promise<T>\r\n  ): void {\r\n    const queue = this.queues.get(provider)\r\n    if (!queue) {\r\n      queuedRequest.reject(new Error(`Provider ${provider} not configured`))\r\n      return\r\n    }\r\n\r\n    // Check queue size limit\r\n    if (queue.length >= this.MAX_QUEUE_SIZE) {\r\n      queuedRequest.reject(new Error(`Queue full for provider ${provider}`))\r\n      return\r\n    }\r\n\r\n    // Add executor to the request\r\n    (queuedRequest as any).executor = executor\r\n\r\n    // Priority queue: high priority requests go first\r\n    if (queuedRequest.request.priority === 'high') {\r\n      queue.unshift(queuedRequest)\r\n    } else {\r\n      queue.push(queuedRequest)\r\n    }\r\n\r\n    // Start processing if not already running\r\n    this.processQueue(provider)\r\n  }\r\n\r\n  private async processQueue(provider: AIVoiceProviderType): Promise<void> {\r\n    if (this.processing.get(provider)) {\r\n      return // Already processing\r\n    }\r\n\r\n    this.processing.set(provider, true)\r\n\r\n    const queue = this.queues.get(provider)\r\n    if (!queue) {\r\n      this.processing.set(provider, false)\r\n      return\r\n    }\r\n\r\n    while (queue.length > 0) {\r\n      const queuedRequest = queue.shift()!\r\n      \r\n      try {\r\n        // Check if request has expired (older than 5 minutes)\r\n        if (Date.now() - queuedRequest.timestamp > 5 * 60 * 1000) {\r\n          queuedRequest.reject(new Error(\"Request expired\"))\r\n          continue\r\n        }\r\n\r\n        // Wait for rate limit availability\r\n        await this.waitForRateLimit(provider, queuedRequest.request)\r\n\r\n        // Execute the request\r\n        const executor = (queuedRequest as any).executor\r\n        const result = await executor()\r\n        \r\n        // Record the request\r\n        this.recordRequest(provider, queuedRequest.request)\r\n        \r\n        queuedRequest.resolve(result)\r\n      } catch (error) {\r\n        // Handle retries\r\n        if (queuedRequest.retryCount < this.MAX_RETRY_COUNT && this.isRetryableError(error)) {\r\n          queuedRequest.retryCount++\r\n          \r\n          // Exponential backoff\r\n          const delay = this.RETRY_DELAY_BASE * Math.pow(2, queuedRequest.retryCount - 1)\r\n          \r\n          setTimeout(() => {\r\n            queue.push(queuedRequest) // Re-queue for retry\r\n          }, delay)\r\n        } else {\r\n          queuedRequest.reject(error)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.processing.set(provider, false)\r\n  }\r\n\r\n  private async waitForRateLimit(\r\n    provider: AIVoiceProviderType,\r\n    request: AudioGenerationRequest\r\n  ): Promise<void> {\r\n    const limits = this.limits.get(provider)\r\n    if (!limits) return\r\n\r\n    while (true) {\r\n      if (this.canMakeRequest(provider, request)) {\r\n        return\r\n      }\r\n\r\n      // Wait before checking again\r\n      await this.sleep(1000) // Wait 1 second\r\n    }\r\n  }\r\n\r\n  private canMakeRequest(\r\n    provider: AIVoiceProviderType,\r\n    request: AudioGenerationRequest\r\n  ): boolean {\r\n    const limits = this.limits.get(provider)\r\n    const state = this.state.get(provider)\r\n    \r\n    if (!limits || !state) return true\r\n\r\n    const now = Date.now()\r\n    \r\n    // Clean up old entries\r\n    this.cleanupOldEntries(state, now)\r\n\r\n    // Check requests per minute limit\r\n    if (state.requests.length >= limits.requestsPerMinute) {\r\n      return false\r\n    }\r\n\r\n    // Check characters per day limit\r\n    const todayCharacters = state.characters.reduce((sum, chars) => sum + chars, 0)\r\n    if (todayCharacters + request.text.length > limits.charactersPerDay) {\r\n      return false\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  private cleanupOldEntries(state: RateLimitState, now: number): void {\r\n    // Remove requests older than 1 minute\r\n    const minuteAgo = now - this.MINUTE_MS\r\n    state.requests = state.requests.filter(timestamp => timestamp > minuteAgo)\r\n\r\n    // Reset daily counters if it's a new day\r\n    if (now - state.lastReset > this.DAY_MS) {\r\n      state.characters = []\r\n      state.lastReset = now\r\n    }\r\n  }\r\n\r\n  private recordRequest(provider: AIVoiceProviderType, request: AudioGenerationRequest): void {\r\n    const state = this.state.get(provider)\r\n    if (!state) return\r\n\r\n    const now = Date.now()\r\n    \r\n    // Record request timestamp\r\n    state.requests.push(now)\r\n    \r\n    // Record character count\r\n    state.characters.push(request.text.length)\r\n  }\r\n\r\n  private isRetryableError(error: any): boolean {\r\n    // Retry on rate limits and temporary service issues\r\n    return error?.code === 'RATE_LIMIT' || \r\n           error?.code === 'SERVICE_UNAVAILABLE' ||\r\n           error?.retryable === true\r\n  }\r\n\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n  }\r\n\r\n  private startQueueProcessor(): void {\r\n    // Process queues every second\r\n    setInterval(() => {\r\n      for (const provider of this.queues.keys()) {\r\n        if (!this.processing.get(provider)) {\r\n          this.processQueue(provider)\r\n        }\r\n      }\r\n    }, 1000)\r\n  }\r\n\r\n  // Public methods for monitoring\r\n  getQueueStatus(): Record<AIVoiceProviderType, {\r\n    queueLength: number\r\n    processing: boolean\r\n    oldestRequest?: number\r\n  }> {\r\n    const status: Record<string, any> = {}\r\n\r\n    for (const [provider, queue] of this.queues.entries()) {\r\n      const oldestRequest = queue.length > 0 ? queue[0].timestamp : undefined\r\n      \r\n      status[provider] = {\r\n        queueLength: queue.length,\r\n        processing: this.processing.get(provider) || false,\r\n        oldestRequest\r\n      }\r\n    }\r\n\r\n    return status as Record<AIVoiceProviderType, {\r\n      queueLength: number\r\n      processing: boolean\r\n      oldestRequest?: number\r\n    }>\r\n  }\r\n\r\n  getRateLimitStatus(): Record<AIVoiceProviderType, {\r\n    requestsInLastMinute: number\r\n    charactersToday: number\r\n    requestsPerMinuteLimit: number\r\n    charactersPerDayLimit: number\r\n    utilizationPercent: number\r\n  }> {\r\n    const status: Record<string, any> = {}\r\n\r\n    for (const [provider, state] of this.state.entries()) {\r\n      const limits = this.limits.get(provider)\r\n      if (!limits) continue\r\n\r\n      const now = Date.now()\r\n      this.cleanupOldEntries(state, now)\r\n\r\n      const requestsInLastMinute = state.requests.length\r\n      const charactersToday = state.characters.reduce((sum, chars) => sum + chars, 0)\r\n      \r\n      const requestUtilization = (requestsInLastMinute / limits.requestsPerMinute) * 100\r\n      const characterUtilization = (charactersToday / limits.charactersPerDay) * 100\r\n      const utilizationPercent = Math.max(requestUtilization, characterUtilization)\r\n\r\n      status[provider] = {\r\n        requestsInLastMinute,\r\n        charactersToday,\r\n        requestsPerMinuteLimit: limits.requestsPerMinute,\r\n        charactersPerDayLimit: limits.charactersPerDay,\r\n        utilizationPercent: Math.round(utilizationPercent)\r\n      }\r\n    }\r\n\r\n    return status as Record<AIVoiceProviderType, {\r\n      requestsInLastMinute: number\r\n      charactersToday: number\r\n      requestsPerMinuteLimit: number\r\n      charactersPerDayLimit: number\r\n      utilizationPercent: number\r\n    }>\r\n  }\r\n\r\n  clearQueue(provider: AIVoiceProviderType): void {\r\n    const queue = this.queues.get(provider)\r\n    if (queue) {\r\n      // Reject all pending requests\r\n      for (const request of queue) {\r\n        request.reject(new Error(\"Queue cleared\"))\r\n      }\r\n      queue.length = 0\r\n    }\r\n  }\r\n\r\n  clearAllQueues(): void {\r\n    for (const provider of this.queues.keys()) {\r\n      this.clearQueue(provider)\r\n    }\r\n  }\r\n\r\n  getEstimatedWaitTime(provider: AIVoiceProviderType): number {\r\n    const queue = this.queues.get(provider)\r\n    const limits = this.limits.get(provider)\r\n    \r\n    if (!queue || !limits || queue.length === 0) {\r\n      return 0\r\n    }\r\n\r\n    // Simple estimation: queue length / requests per minute * 60 seconds\r\n    return Math.ceil((queue.length / limits.requestsPerMinute) * 60)\r\n  }\r\n}\r\n\r\n// Global rate limiter instance\r\nlet rateLimiterInstance: RateLimiter | null = null\r\n\r\nexport const getRateLimiter = (): RateLimiter => {\r\n  if (!rateLimiterInstance) {\r\n    rateLimiterInstance = new RateLimiter()\r\n  }\r\n  return rateLimiterInstance\r\n}","import type {\r\n  AIVoiceProvider,\r\n  VoiceOptions,\r\n  AIVoiceProfile,\r\n  AIVoiceSettings,\r\n  AudioGenerationRequest,\r\n  AIVoiceProviderType\r\n} from \"./ai-voice-types\"\r\nimport {\r\n  AIVoiceError,\r\n  RateLimitError,\r\n  AuthenticationError,\r\n  ServiceUnavailableError\r\n} from \"./ai-voice-types\"\r\nimport { ProviderFactory, createProviderSafely } from \"./providers/provider-factory\"\r\nimport { getCacheManager } from \"./cache-manager\"\r\nimport { getRateLimiter } from \"./rate-limiter\"\r\n\r\nexport class AIVoiceService {\r\n  private settings: AIVoiceSettings\r\n  private providers: Map<AIVoiceProviderType, AIVoiceProvider> = new Map()\r\n  private providerHealth: Map<AIVoiceProviderType, {\r\n    healthy: boolean\r\n    lastCheck: number\r\n    consecutiveFailures: number\r\n    nextRetry: number\r\n  }> = new Map()\r\n\r\n  private readonly HEALTH_CHECK_INTERVAL = 5 * 60 * 1000 // 5 minutes\r\n  private readonly MAX_CONSECUTIVE_FAILURES = 3\r\n  private readonly RETRY_BACKOFF_BASE = 2 * 60 * 1000 // 2 minutes\r\n\r\n  constructor(settings: AIVoiceSettings) {\r\n    this.settings = settings\r\n    this.initializeProviders()\r\n  }\r\n\r\n  async updateSettings(settings: AIVoiceSettings): Promise<void> {\r\n    this.settings = settings\r\n    await this.initializeProviders()\r\n\r\n    // Update cache manager settings\r\n    const cacheManager = getCacheManager()\r\n    cacheManager.updateSettings(settings)\r\n\r\n    // Update rate limiter settings\r\n    const rateLimiter = getRateLimiter()\r\n    for (const [providerType, config] of Object.entries(settings.providerConfigs)) {\r\n      if (config.enabled) {\r\n        rateLimiter.updateProviderLimits(providerType as AIVoiceProviderType, config.rateLimit)\r\n      }\r\n    }\r\n  }\r\n\r\n  private async initializeProviders(): Promise<void> {\r\n    this.providers.clear()\r\n    this.providerHealth.clear()\r\n\r\n    for (const [providerType, config] of Object.entries(this.settings.providerConfigs)) {\r\n      if (!config.enabled) continue\r\n\r\n      const type = providerType as AIVoiceProviderType\r\n      const result = await createProviderSafely(type, config)\r\n\r\n      if (result.provider) {\r\n        this.providers.set(type, result.provider)\r\n        this.providerHealth.set(type, {\r\n          healthy: true,\r\n          lastCheck: Date.now(),\r\n          consecutiveFailures: 0,\r\n          nextRetry: 0\r\n        })\r\n      } else {\r\n        console.warn(`Failed to initialize ${type} provider:`, result.error)\r\n        this.providerHealth.set(type, {\r\n          healthy: false,\r\n          lastCheck: Date.now(),\r\n          consecutiveFailures: 1,\r\n          nextRetry: Date.now() + this.RETRY_BACKOFF_BASE\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  async generateSpeech(\r\n    text: string,\r\n    type: 'announcement' | 'prayer' | 'bell' | 'general',\r\n    options?: Partial<VoiceOptions>\r\n  ): Promise<AudioBuffer> {\r\n    if (!this.settings.aiVoiceEnabled) {\r\n      throw new AIVoiceError(\"AI voice generation is disabled\", \"System\", \"DISABLED\", false)\r\n    }\r\n\r\n    // Get voice profile for the type\r\n    const voiceProfile = this.settings.voiceProfiles[type]\r\n    if (!voiceProfile) {\r\n      throw new AIVoiceError(`No voice profile configured for type: ${type}`, \"System\", \"CONFIG_ERROR\", false)\r\n    }\r\n\r\n    // Build voice options\r\n    const voiceOptions: VoiceOptions = {\r\n      voice: options?.voice || voiceProfile.id,\r\n      language: options?.language || voiceProfile.language,\r\n      speed: options?.speed || 1.0,\r\n      pitch: options?.pitch || 1.0,\r\n      stability: options?.stability,\r\n      clarity: options?.clarity\r\n    }\r\n\r\n    // Check cache first\r\n    const cacheManager = getCacheManager()\r\n    const cachedAudio = await cacheManager.retrieveAudio(text, voiceProfile.id, voiceProfile.provider)\r\n    if (cachedAudio) {\r\n      return cachedAudio\r\n    }\r\n\r\n    // Generate with provider failover\r\n    const audioBuffer = await this.generateWithFailover(text, voiceOptions, voiceProfile)\r\n\r\n    // Cache the result\r\n    await cacheManager.storeAudio(text, voiceProfile.id, voiceProfile.provider, audioBuffer)\r\n\r\n    return audioBuffer\r\n  }\r\n\r\n  private async generateWithFailover(\r\n    text: string,\r\n    options: VoiceOptions,\r\n    voiceProfile: AIVoiceProfile\r\n  ): Promise<AudioBuffer> {\r\n    const providers = this.getOrderedProviders(voiceProfile.provider)\r\n    let lastError: AIVoiceError | null = null\r\n    const rateLimiter = getRateLimiter()\r\n\r\n    for (const { type, provider } of providers) {\r\n      try {\r\n        // Check if provider is healthy\r\n        if (!await this.isProviderHealthy(type)) {\r\n          continue\r\n        }\r\n\r\n        // Create generation request\r\n        const request: AudioGenerationRequest = {\r\n          id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n          text,\r\n          type: 'general', // Will be set properly by caller\r\n          voice: voiceProfile,\r\n          options,\r\n          priority: 'normal',\r\n          timestamp: Date.now(),\r\n          status: 'pending',\r\n          retryCount: 0,\r\n          estimatedCost: provider.estimateCost(text, options.voice)\r\n        }\r\n\r\n        // Execute with rate limiting\r\n        const audioBuffer = await rateLimiter.executeWithRateLimit(\r\n          type,\r\n          request,\r\n          () => provider.generateSpeech(text, options)\r\n        )\r\n\r\n        // Mark provider as healthy on success\r\n        this.markProviderHealthy(type)\r\n\r\n        return audioBuffer\r\n      } catch (error) {\r\n        lastError = error instanceof AIVoiceError ? error :\r\n          new ServiceUnavailableError(type)\r\n\r\n        // Handle different error types\r\n        if (error instanceof RateLimitError) {\r\n          this.handleRateLimit(type, error.retryAfter)\r\n        } else if (error instanceof AuthenticationError) {\r\n          this.markProviderUnhealthy(type)\r\n        } else if (error instanceof ServiceUnavailableError) {\r\n          this.markProviderUnhealthy(type)\r\n        }\r\n\r\n        console.warn(`Provider ${type} failed:`, error)\r\n      }\r\n    }\r\n\r\n    // All providers failed\r\n    throw lastError || new AIVoiceError(\r\n      \"All voice providers failed\",\r\n      \"System\",\r\n      \"ALL_PROVIDERS_FAILED\",\r\n      true\r\n    )\r\n  }\r\n\r\n  private getOrderedProviders(preferredProvider: string): Array<{\r\n    type: AIVoiceProviderType\r\n    provider: AIVoiceProvider\r\n  }> {\r\n    const providers: Array<{\r\n      type: AIVoiceProviderType\r\n      provider: AIVoiceProvider\r\n      priority: number\r\n    }> = []\r\n\r\n    // Add all available providers with their priorities\r\n    for (const [type, provider] of this.providers.entries()) {\r\n      const config = this.settings.providerConfigs[type]\r\n      if (config?.enabled) {\r\n        let priority = config.priority\r\n\r\n        // Boost priority for preferred provider\r\n        if (type === preferredProvider) {\r\n          priority -= 100 // Lower number = higher priority\r\n        }\r\n\r\n        providers.push({ type, provider, priority })\r\n      }\r\n    }\r\n\r\n    // Sort by priority (lower number = higher priority)\r\n    providers.sort((a, b) => a.priority - b.priority)\r\n\r\n    return providers.map(({ type, provider }) => ({ type, provider }))\r\n  }\r\n\r\n  private async isProviderHealthy(type: AIVoiceProviderType): Promise<boolean> {\r\n    const health = this.providerHealth.get(type)\r\n    if (!health) return false\r\n\r\n    // If marked unhealthy and retry time hasn't passed, skip\r\n    if (!health.healthy && Date.now() < health.nextRetry) {\r\n      return false\r\n    }\r\n\r\n    // If it's been a while since last check, do a health check\r\n    if (Date.now() - health.lastCheck > this.HEALTH_CHECK_INTERVAL) {\r\n      await this.performHealthCheck(type)\r\n    }\r\n\r\n    return this.providerHealth.get(type)?.healthy || false\r\n  }\r\n\r\n  private async performHealthCheck(type: AIVoiceProviderType): Promise<void> {\r\n    const provider = this.providers.get(type)\r\n    const health = this.providerHealth.get(type)\r\n\r\n    if (!provider || !health) return\r\n\r\n    try {\r\n      const isValid = await provider.validateCredentials()\r\n\r\n      if (isValid) {\r\n        this.markProviderHealthy(type)\r\n      } else {\r\n        this.markProviderUnhealthy(type)\r\n      }\r\n    } catch (error) {\r\n      this.markProviderUnhealthy(type)\r\n    }\r\n  }\r\n\r\n  private markProviderHealthy(type: AIVoiceProviderType): void {\r\n    const health = this.providerHealth.get(type)\r\n    if (health) {\r\n      health.healthy = true\r\n      health.lastCheck = Date.now()\r\n      health.consecutiveFailures = 0\r\n      health.nextRetry = 0\r\n    }\r\n  }\r\n\r\n  private markProviderUnhealthy(type: AIVoiceProviderType): void {\r\n    const health = this.providerHealth.get(type)\r\n    if (health) {\r\n      health.healthy = false\r\n      health.lastCheck = Date.now()\r\n      health.consecutiveFailures += 1\r\n\r\n      // Exponential backoff for retry\r\n      const backoffMultiplier = Math.pow(2, Math.min(health.consecutiveFailures - 1, 5))\r\n      health.nextRetry = Date.now() + (this.RETRY_BACKOFF_BASE * backoffMultiplier)\r\n    }\r\n  }\r\n\r\n  private handleRateLimit(type: AIVoiceProviderType, retryAfter?: number): void {\r\n    const health = this.providerHealth.get(type)\r\n    if (health) {\r\n      health.healthy = false\r\n      health.lastCheck = Date.now()\r\n      health.nextRetry = Date.now() + (retryAfter ? retryAfter * 1000 : this.RETRY_BACKOFF_BASE)\r\n    }\r\n  }\r\n\r\n  async getAvailableVoices(): Promise<Record<AIVoiceProviderType, AIVoiceProfile[]>> {\r\n    const voices: Record<string, AIVoiceProfile[]> = {}\r\n\r\n    for (const [type, provider] of this.providers.entries()) {\r\n      try {\r\n        if (await this.isProviderHealthy(type)) {\r\n          voices[type] = await provider.getAvailableVoices()\r\n        }\r\n      } catch (error) {\r\n        console.warn(`Failed to get voices from ${type}:`, error)\r\n        voices[type] = []\r\n      }\r\n    }\r\n\r\n    return voices as Record<AIVoiceProviderType, AIVoiceProfile[]>\r\n  }\r\n\r\n  async validateAllProviders(): Promise<Record<AIVoiceProviderType, {\r\n    valid: boolean\r\n    error?: string\r\n  }>> {\r\n    const results: Record<string, { valid: boolean; error?: string }> = {}\r\n\r\n    for (const [type, provider] of this.providers.entries()) {\r\n      try {\r\n        const isValid = await provider.validateCredentials()\r\n        results[type] = { valid: isValid }\r\n\r\n        if (isValid) {\r\n          this.markProviderHealthy(type)\r\n        } else {\r\n          this.markProviderUnhealthy(type)\r\n          results[type].error = \"Invalid credentials\"\r\n        }\r\n      } catch (error) {\r\n        this.markProviderUnhealthy(type)\r\n        results[type] = {\r\n          valid: false,\r\n          error: error instanceof Error ? error.message : \"Unknown error\"\r\n        }\r\n      }\r\n    }\r\n\r\n    return results as Record<AIVoiceProviderType, { valid: boolean; error?: string }>\r\n  }\r\n\r\n  getProviderHealth(): Record<AIVoiceProviderType, {\r\n    healthy: boolean\r\n    lastCheck: number\r\n    consecutiveFailures: number\r\n    nextRetry: number\r\n  }> {\r\n    const health: Record<string, any> = {}\r\n\r\n    for (const [type, healthInfo] of this.providerHealth.entries()) {\r\n      health[type] = { ...healthInfo }\r\n    }\r\n\r\n    return health as Record<AIVoiceProviderType, {\r\n      healthy: boolean\r\n      lastCheck: number\r\n      consecutiveFailures: number\r\n      nextRetry: number\r\n    }>\r\n  }\r\n\r\n  async estimateCost(text: string, type: 'announcement' | 'prayer' | 'bell' | 'general'): Promise<{\r\n    provider: string\r\n    cost: number\r\n    cached: boolean\r\n  }> {\r\n    const voiceProfile = this.settings.voiceProfiles[type]\r\n    if (!voiceProfile) {\r\n      return { provider: \"unknown\", cost: 0, cached: false }\r\n    }\r\n\r\n    // Check if already cached\r\n    const cacheManager = getCacheManager()\r\n    const isCached = await cacheManager.hasAudio(text, voiceProfile.id, voiceProfile.provider)\r\n\r\n    if (isCached) {\r\n      return { provider: voiceProfile.provider, cost: 0, cached: true }\r\n    }\r\n\r\n    // Get provider and estimate cost\r\n    const provider = this.providers.get(voiceProfile.provider as AIVoiceProviderType)\r\n    if (!provider) {\r\n      return { provider: voiceProfile.provider, cost: 0, cached: false }\r\n    }\r\n\r\n    const cost = provider.estimateCost(text, voiceProfile.id)\r\n    return { provider: voiceProfile.provider, cost, cached: false }\r\n  }\r\n\r\n  getSettings(): AIVoiceSettings {\r\n    return { ...this.settings }\r\n  }\r\n\r\n  isEnabled(): boolean {\r\n    return this.settings.aiVoiceEnabled\r\n  }\r\n\r\n  hasHealthyProviders(): boolean {\r\n    for (const health of this.providerHealth.values()) {\r\n      if (health.healthy) return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  getRateLimitStatus(): Record<AIVoiceProviderType, {\r\n    requestsInLastMinute: number\r\n    charactersToday: number\r\n    requestsPerMinuteLimit: number\r\n    charactersPerDayLimit: number\r\n    utilizationPercent: number\r\n  }> {\r\n    const rateLimiter = getRateLimiter()\r\n    return rateLimiter.getRateLimitStatus()\r\n  }\r\n\r\n  getQueueStatus(): Record<AIVoiceProviderType, {\r\n    queueLength: number\r\n    processing: boolean\r\n    oldestRequest?: number\r\n  }> {\r\n    const rateLimiter = getRateLimiter()\r\n    return rateLimiter.getQueueStatus()\r\n  }\r\n\r\n  getEstimatedWaitTime(provider: AIVoiceProviderType): number {\r\n    const rateLimiter = getRateLimiter()\r\n    return rateLimiter.getEstimatedWaitTime(provider)\r\n  }\r\n}\r\n\r\n// Global service instance\r\nlet aiVoiceServiceInstance: AIVoiceService | null = null\r\n\r\nexport const getAIVoiceService = (): AIVoiceService | null => {\r\n  return aiVoiceServiceInstance\r\n}\r\n\r\nexport const initializeAIVoiceService = (settings: AIVoiceSettings): AIVoiceService => {\r\n  aiVoiceServiceInstance = new AIVoiceService(settings)\r\n  return aiVoiceServiceInstance\r\n}\r\n\r\nexport const updateAIVoiceService = async (settings: AIVoiceSettings): Promise<void> => {\r\n  if (aiVoiceServiceInstance) {\r\n    await aiVoiceServiceInstance.updateSettings(settings)\r\n  } else {\r\n    initializeAIVoiceService(settings)\r\n  }\r\n}","import type { Language, VoiceType } from \"./store\"\r\nimport { getAIVoiceService } from \"./ai-voice-service\"\r\nimport { AIVoiceError } from \"./ai-voice-types\"\r\nimport { playBrowserTTS, playAudioBuffer, generateAIVoice } from \"./voice-utils\"\r\n\r\nexport interface VoiceFallbackOptions {\r\n  maxRetries?: number\r\n  retryDelay?: number\r\n  preferAI?: boolean\r\n  fallbackToTTS?: boolean\r\n  logErrors?: boolean\r\n}\r\n\r\nexport interface VoicePlaybackResult {\r\n  success: boolean\r\n  method: 'ai' | 'network-tts' | 'tts' | 'none'\r\n  provider?: string\r\n  error?: string\r\n  retries: number\r\n  duration?: number\r\n}\r\n\r\nexport class VoiceFallbackHandler {\r\n  private defaultOptions: Required<VoiceFallbackOptions> = {\r\n    maxRetries: 2,\r\n    retryDelay: 1000,\r\n    preferAI: true,\r\n    fallbackToTTS: true,\r\n    logErrors: true\r\n  }\r\n\r\n  async playWithFallback(\r\n    text: string,\r\n    voice: VoiceType,\r\n    language: Language = \"english\",\r\n    type: 'announcement' | 'prayer' | 'bell' | 'general' = 'general',\r\n    options?: VoiceFallbackOptions\r\n  ): Promise<VoicePlaybackResult> {\r\n    const opts = { ...this.defaultOptions, ...options }\r\n    const startTime = Date.now()\r\n    let retries = 0\r\n    let lastError: string | undefined\r\n\r\n    // Determine playback strategy\r\n    const strategies = this.getPlaybackStrategies(opts)\r\n\r\n    for (const strategy of strategies) {\r\n      for (let attempt = 0; attempt <= opts.maxRetries; attempt++) {\r\n        try {\r\n          const success = await this.executeStrategy(strategy, text, voice, language, type)\r\n\r\n          if (success) {\r\n            const duration = Date.now() - startTime\r\n            return {\r\n              success: true,\r\n              method: strategy,\r\n              provider: strategy === 'ai' ? await this.getActiveProvider(type) : undefined,\r\n              retries: attempt,\r\n              duration\r\n            }\r\n          }\r\n        } catch (error) {\r\n          lastError = error instanceof Error ? error.message : 'Unknown error'\r\n          retries = attempt + 1\r\n\r\n          if (opts.logErrors) {\r\n            console.warn(`[VoiceFallback] ${strategy} attempt ${attempt + 1} failed:`, lastError)\r\n          }\r\n\r\n          // Wait before retry (except on last attempt)\r\n          if (attempt < opts.maxRetries) {\r\n            await this.sleep(opts.retryDelay * (attempt + 1)) // Exponential backoff\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // All strategies failed\r\n    const duration = Date.now() - startTime\r\n    return {\r\n      success: false,\r\n      method: 'none',\r\n      error: lastError || 'All playback methods failed',\r\n      retries,\r\n      duration\r\n    }\r\n  }\r\n\r\n  private getPlaybackStrategies(options: VoiceFallbackOptions): Array<'ai' | 'network-tts' | 'tts'> {\r\n    const strategies: Array<'ai' | 'network-tts' | 'tts'> = []\r\n\r\n    if (options.preferAI) {\r\n      strategies.push('ai')\r\n      strategies.push('network-tts')\r\n      if (options.fallbackToTTS) {\r\n        strategies.push('tts')\r\n      }\r\n    } else {\r\n      strategies.push('network-tts')\r\n      strategies.push('tts')\r\n      if (options.preferAI) {\r\n        strategies.push('ai')\r\n      }\r\n    }\r\n\r\n    return strategies\r\n  }\r\n\r\n  private async executeStrategy(\r\n    strategy: 'ai' | 'network-tts' | 'tts',\r\n    text: string,\r\n    voice: VoiceType,\r\n    language: Language,\r\n    type: 'announcement' | 'prayer' | 'bell' | 'general'\r\n  ): Promise<boolean> {\r\n    switch (strategy) {\r\n      case 'ai':\r\n        return await this.tryAIVoice(text, type, { voice, language })\r\n      case 'network-tts':\r\n        return await this.tryNetworkTTS(text, language)\r\n      case 'tts':\r\n        return await this.tryBrowserTTS(text, voice, language)\r\n      default:\r\n        throw new Error(`Unknown strategy: ${strategy}`)\r\n    }\r\n  }\r\n\r\n  private async tryNetworkTTS(text: string, language: Language): Promise<boolean> {\r\n    // Network TTS removed - use browser TTS instead\r\n    console.log('[VoiceFallback] Network TTS not available, using browser TTS')\r\n    return await this.tryBrowserTTS(text, 'standard-male', language)\r\n  }\r\n\r\n  private async tryAIVoice(\r\n    text: string,\r\n    type: 'announcement' | 'prayer' | 'bell' | 'general',\r\n    options: { voice?: VoiceType; language?: Language }\r\n  ): Promise<boolean> {\r\n    const aiVoiceService = getAIVoiceService()\r\n\r\n    // Quick availability check\r\n    if (!aiVoiceService || !aiVoiceService.isEnabled()) {\r\n      throw new AIVoiceError(\"AI voice service not available\", \"System\", \"SERVICE_UNAVAILABLE\", false)\r\n    }\r\n\r\n    if (!aiVoiceService.hasHealthyProviders()) {\r\n      throw new AIVoiceError(\"No healthy AI voice providers\", \"System\", \"NO_PROVIDERS\", true)\r\n    }\r\n\r\n    // Generate and play AI voice\r\n    const audioBuffer = await generateAIVoice(text, type, options)\r\n    if (!audioBuffer) {\r\n      throw new AIVoiceError(\"AI voice generation returned null\", \"System\", \"GENERATION_FAILED\", true)\r\n    }\r\n\r\n    await playAudioBuffer(audioBuffer)\r\n    return true\r\n  }\r\n\r\n  private async tryBrowserTTS(\r\n    text: string,\r\n    voice: VoiceType,\r\n    language: Language\r\n  ): Promise<boolean> {\r\n    // Check TTS availability\r\n    if (typeof window === \"undefined\" || !(\"speechSynthesis\" in window) || !window.speechSynthesis) {\r\n      throw new Error(\"Browser TTS not available\")\r\n    }\r\n\r\n    const result = await playBrowserTTS(text, voice, language)\r\n    if (!result) {\r\n      throw new Error(\"Browser TTS playback failed\")\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  private async getActiveProvider(type: 'announcement' | 'prayer' | 'bell' | 'general'): Promise<string | undefined> {\r\n    const aiVoiceService = getAIVoiceService()\r\n    if (!aiVoiceService) return undefined\r\n\r\n    const settings = aiVoiceService.getSettings()\r\n    const voiceProfile = settings.voiceProfiles[type]\r\n    return voiceProfile?.provider\r\n  }\r\n\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n  }\r\n\r\n  // Utility methods for system health checking\r\n  async checkSystemHealth(): Promise<{\r\n    ai: { available: boolean; providers: string[]; error?: string }\r\n    tts: { available: boolean; error?: string }\r\n    recommendation: 'ai' | 'tts' | 'both' | 'none'\r\n  }> {\r\n    const aiStatus = await this.checkAIVoiceHealth()\r\n    const ttsStatus = this.checkTTSHealth()\r\n\r\n    let recommendation: 'ai' | 'tts' | 'both' | 'none' = 'none'\r\n\r\n    if (aiStatus.available && ttsStatus.available) {\r\n      recommendation = 'both'\r\n    } else if (aiStatus.available) {\r\n      recommendation = 'ai'\r\n    } else if (ttsStatus.available) {\r\n      recommendation = 'tts'\r\n    }\r\n\r\n    return {\r\n      ai: aiStatus,\r\n      tts: ttsStatus,\r\n      recommendation\r\n    }\r\n  }\r\n\r\n  private async checkAIVoiceHealth(): Promise<{\r\n    available: boolean\r\n    providers: string[]\r\n    error?: string\r\n  }> {\r\n    try {\r\n      const aiVoiceService = getAIVoiceService()\r\n\r\n      if (!aiVoiceService) {\r\n        return { available: false, providers: [], error: \"AI voice service not initialized\" }\r\n      }\r\n\r\n      if (!aiVoiceService.isEnabled()) {\r\n        return { available: false, providers: [], error: \"AI voice disabled in settings\" }\r\n      }\r\n\r\n      const health = aiVoiceService.getProviderHealth()\r\n      const healthyProviders = Object.entries(health)\r\n        .filter(([_, status]) => status.healthy)\r\n        .map(([provider, _]) => provider)\r\n\r\n      if (healthyProviders.length === 0) {\r\n        return { available: false, providers: [], error: \"No healthy providers available\" }\r\n      }\r\n\r\n      return { available: true, providers: healthyProviders }\r\n    } catch (error) {\r\n      return {\r\n        available: false,\r\n        providers: [],\r\n        error: error instanceof Error ? error.message : \"Unknown error\"\r\n      }\r\n    }\r\n  }\r\n\r\n  private checkTTSHealth(): { available: boolean; error?: string } {\r\n    if (typeof window === \"undefined\") {\r\n      return { available: false, error: \"Not in browser environment\" }\r\n    }\r\n\r\n    if (!(\"speechSynthesis\" in window)) {\r\n      return { available: false, error: \"Speech Synthesis API not supported\" }\r\n    }\r\n\r\n    if (!window.speechSynthesis) {\r\n      return { available: false, error: \"Speech Synthesis API not available\" }\r\n    }\r\n\r\n    return { available: true }\r\n  }\r\n\r\n  // Performance monitoring\r\n  async measurePerformance(\r\n    text: string,\r\n    voice: VoiceType,\r\n    language: Language,\r\n    type: 'announcement' | 'prayer' | 'bell' | 'general',\r\n    iterations: number = 3\r\n  ): Promise<{\r\n    ai: { avgTime: number; successRate: number; errors: string[] }\r\n    tts: { avgTime: number; successRate: number; errors: string[] }\r\n  }> {\r\n    const aiResults: { time: number; success: boolean; error?: string }[] = []\r\n    const ttsResults: { time: number; success: boolean; error?: string }[] = []\r\n\r\n    // Test AI voice performance\r\n    for (let i = 0; i < iterations; i++) {\r\n      const startTime = Date.now()\r\n      try {\r\n        await this.tryAIVoice(text, type, { voice, language })\r\n        aiResults.push({ time: Date.now() - startTime, success: true })\r\n      } catch (error) {\r\n        aiResults.push({\r\n          time: Date.now() - startTime,\r\n          success: false,\r\n          error: error instanceof Error ? error.message : 'Unknown error'\r\n        })\r\n      }\r\n\r\n      // Small delay between tests\r\n      await this.sleep(500)\r\n    }\r\n\r\n    // Test TTS performance\r\n    for (let i = 0; i < iterations; i++) {\r\n      const startTime = Date.now()\r\n      try {\r\n        await this.tryBrowserTTS(text, voice, language)\r\n        ttsResults.push({ time: Date.now() - startTime, success: true })\r\n      } catch (error) {\r\n        ttsResults.push({\r\n          time: Date.now() - startTime,\r\n          success: false,\r\n          error: error instanceof Error ? error.message : 'Unknown error'\r\n        })\r\n      }\r\n\r\n      // Small delay between tests\r\n      await this.sleep(500)\r\n    }\r\n\r\n    return {\r\n      ai: {\r\n        avgTime: aiResults.reduce((sum, r) => sum + r.time, 0) / aiResults.length,\r\n        successRate: (aiResults.filter(r => r.success).length / aiResults.length) * 100,\r\n        errors: aiResults.filter(r => !r.success).map(r => r.error || 'Unknown')\r\n      },\r\n      tts: {\r\n        avgTime: ttsResults.reduce((sum, r) => sum + r.time, 0) / ttsResults.length,\r\n        successRate: (ttsResults.filter(r => r.success).length / ttsResults.length) * 100,\r\n        errors: ttsResults.filter(r => !r.success).map(r => r.error || 'Unknown')\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Global fallback handler instance\r\nlet fallbackHandlerInstance: VoiceFallbackHandler | null = null\r\n\r\nexport const getVoiceFallbackHandler = (): VoiceFallbackHandler => {\r\n  if (!fallbackHandlerInstance) {\r\n    fallbackHandlerInstance = new VoiceFallbackHandler()\r\n  }\r\n  return fallbackHandlerInstance\r\n}\r\n\r\n// Convenience functions for common use cases\r\nexport const playWithSmartFallback = async (\r\n  text: string,\r\n  voice: VoiceType,\r\n  language: Language = \"english\",\r\n  type: 'announcement' | 'prayer' | 'bell' | 'general' = 'general'\r\n): Promise<boolean> => {\r\n  const handler = getVoiceFallbackHandler()\r\n  const result = await handler.playWithFallback(text, voice, language, type)\r\n  return result.success\r\n}\r\n\r\nexport const playAnnouncementWithFallback = async (text: string): Promise<boolean> => {\r\n  return playWithSmartFallback(text, \"standard-male\", \"english\", \"announcement\")\r\n}\r\n\r\nexport const playPrayerCallWithFallback = async (prayerName: string): Promise<boolean> => {\r\n  const prayerText = `${prayerName} prayer time. Come and pray.`\r\n  return playWithSmartFallback(prayerText, \"azan-islamic\", \"arabic\", \"prayer\")\r\n}\r\n\r\nexport const playBellWithFallback = async (eventName: string): Promise<boolean> => {\r\n  const bellText = `Bell ring for ${eventName}`\r\n  return playWithSmartFallback(bellText, \"standard-female\", \"english\", \"bell\")\r\n}","import type { Language, VoiceType } from \"./store\"\nimport { getAIVoiceService } from \"./ai-voice-service\"\nimport { AIVoiceError } from \"./ai-voice-types\"\nimport { getVoiceFallbackHandler } from \"./voice-fallback\"\n\nexport const VOICE_OPTIONS: Record<VoiceType, { name: string; language: Language; description: string }> = {\n  \"standard-male\": { name: \"Standard Male\", language: \"english\", description: \"Clear English voice\" },\n  \"standard-female\": { name: \"Standard Female\", language: \"english\", description: \"Clear English voice\" },\n  \"azan-islamic\": { name: \"Islamic Azan\", language: \"arabic\", description: \"Islamic prayer call (Azan)\" },\n  hausa: { name: \"Hausa\", language: \"hausa\", description: \"Native Hausa speaker\" },\n  twi: { name: \"Twi\", language: \"twi\", description: \"Native Twi speaker\" },\n  arabic: { name: \"Arabic\", language: \"arabic\", description: \"Native Arabic speaker\" },\n\n  // OpenAI Voices\n  \"openai-alloy\": { name: \"OpenAI Alloy\", language: \"english\", description: \"Neutral, balanced voice\" },\n  \"openai-echo\": { name: \"OpenAI Echo\", language: \"english\", description: \"Warm, rounded male voice\" },\n  \"openai-fable\": { name: \"OpenAI Fable\", language: \"english\", description: \"British accent, storytelling voice\" },\n  \"openai-onyx\": { name: \"OpenAI Onyx\", language: \"english\", description: \"Deep, authoritative male voice\" },\n  \"openai-nova\": { name: \"OpenAI Nova\", language: \"english\", description: \"Energetic female voice\" },\n  \"openai-shimmer\": { name: \"OpenAI Shimmer\", language: \"english\", description: \"Clear, bright female voice\" },\n\n  // ElevenLabs Voices\n  \"elevenlabs-rachel\": { name: \"ElevenLabs Rachel\", language: \"english\", description: \"American female, narrative\" },\n  \"elevenlabs-drew\": { name: \"ElevenLabs Drew\", language: \"english\", description: \"American male, news\" },\n  \"elevenlabs-clyde\": { name: \"ElevenLabs Clyde\", language: \"english\", description: \"American male, deep\" },\n  \"elevenlabs-paul\": { name: \"ElevenLabs Paul\", language: \"english\", description: \"American male, soft\" },\n\n  // Azure Voices\n  \"azure-jenny\": { name: \"Azure Jenny\", language: \"english\", description: \"American female, conversational\" },\n  \"azure-guy\": { name: \"Azure Guy\", language: \"english\", description: \"American male, conversational\" },\n  \"azure-aria\": { name: \"Azure Aria\", language: \"english\", description: \"American female, helpful\" },\n  \"azure-davis\": { name: \"Azure Davis\", language: \"english\", description: \"American male, casual\" },\n}\n\nexport const LANGUAGE_NAMES: Record<Language, string> = {\n  english: \"English\",\n  hausa: \"Hausa\",\n  twi: \"Twi\",\n  arabic: \"Arabic\",\n}\n\n// Voice configuration with pitch and rate adjustments\n// Enhanced with MORE NOTICEABLE differences between voices\nconst VOICE_CONFIG: Record<VoiceType, { pitch: number; rate: number; volume: number }> = {\n  \"standard-male\": { pitch: 0.7, rate: 0.95, volume: 1 },      // Lower, slower\n  \"standard-female\": { pitch: 1.4, rate: 1.05, volume: 1 },    // Higher, faster\n  \"azan-islamic\": { pitch: 1.3, rate: 0.75, volume: 1 },       // High, slow (reverent)\n  hausa: { pitch: 1.15, rate: 0.9, volume: 1 },\n  twi: { pitch: 1.1, rate: 0.9, volume: 1 },\n  arabic: { pitch: 1.25, rate: 0.85, volume: 1 },\n\n  // OpenAI Voices - ENHANCED DIFFERENCES\n  \"openai-alloy\": { pitch: 1.0, rate: 1.0, volume: 1 },        // Neutral baseline\n  \"openai-echo\": { pitch: 0.85, rate: 0.95, volume: 1 },       // Warm male - lower, slower\n  \"openai-fable\": { pitch: 1.1, rate: 1.05, volume: 1 },       // British - higher, faster\n  \"openai-onyx\": { pitch: 0.7, rate: 0.9, volume: 1 },         // Deep male - VERY low, slow\n  \"openai-nova\": { pitch: 1.3, rate: 1.1, volume: 1 },         // Energetic female - high, fast\n  \"openai-shimmer\": { pitch: 1.35, rate: 1.05, volume: 1 },    // Bright female - VERY high\n\n  // ElevenLabs Voices - ENHANCED DIFFERENCES\n  \"elevenlabs-rachel\": { pitch: 1.25, rate: 1.0, volume: 1 },  // Female narrative - higher\n  \"elevenlabs-drew\": { pitch: 0.9, rate: 1.0, volume: 1 },     // Male news - lower\n  \"elevenlabs-clyde\": { pitch: 0.75, rate: 0.95, volume: 1 },  // Deep male - very low\n  \"elevenlabs-paul\": { pitch: 0.95, rate: 0.9, volume: 1 },    // Soft male - low, slow\n\n  // Azure Voices - ENHANCED DIFFERENCES\n  \"azure-jenny\": { pitch: 1.3, rate: 1.05, volume: 1 },        // Female - higher, faster\n  \"azure-guy\": { pitch: 0.8, rate: 0.95, volume: 1 },          // Male - lower, slower\n  \"azure-aria\": { pitch: 1.35, rate: 1.1, volume: 1 },         // Helpful female - high, fast\n  \"azure-davis\": { pitch: 0.85, rate: 0.9, volume: 1 },        // Casual male - low, slow\n}\n\nexport const playTextToSpeech = async (\n  text: string,\n  voice: VoiceType,\n  language: Language = \"english\",\n  repeatCount?: number\n) => {\n  // Get repeat count from store settings if not provided\n  const { useStore } = await import(\"./store\")\n  const settings = useStore.getState().settings\n  const timesToRepeat = repeatCount ?? settings.defaultRepeatCount ?? 1\n\n  console.log(`[v0] Playing text ${timesToRepeat} time(s): \"${text.substring(0, 50)}...\"`)\n\n  let allSuccessful = true\n\n  for (let i = 0; i < timesToRepeat; i++) {\n    console.log(`[v0] Playing repetition ${i + 1} of ${timesToRepeat}`)\n\n    // Use the comprehensive fallback system\n    const fallbackHandler = getVoiceFallbackHandler()\n    const result = await fallbackHandler.playWithFallback(text, voice, language, 'general', {\n      maxRetries: 1,\n      retryDelay: 500,\n      preferAI: true,\n      fallbackToTTS: true,\n      logErrors: false // Keep console clean for regular usage\n    })\n\n    if (!result.success) {\n      allSuccessful = false\n      console.error(`[v0] Repetition ${i + 1} failed`)\n    }\n\n    // Add delay between repetitions (except for the last one)\n    if (i < timesToRepeat - 1) {\n      await new Promise(resolve => setTimeout(resolve, 1000)) // 1 second delay\n    }\n  }\n\n  console.log(`[v0] Completed ${timesToRepeat} repetitions. Success: ${allSuccessful}`)\n  return allSuccessful\n}\n\n// New AI voice generation function\nexport const generateAIVoice = async (\n  text: string,\n  type: 'announcement' | 'prayer' | 'bell' | 'general' = 'general',\n  options?: { voice?: VoiceType; language?: Language; speed?: number; pitch?: number }\n): Promise<AudioBuffer | null> => {\n  try {\n    const aiVoiceService = getAIVoiceService()\n    if (!aiVoiceService || !aiVoiceService.isEnabled()) {\n      return null\n    }\n\n    console.log(\"[v0] Generating AI voice - Text:\", text.substring(0, 50), \"Type:\", type)\n\n    const voiceOptions = {\n      voice: options?.voice,\n      language: options?.language,\n      speed: options?.speed || 1.0,\n      pitch: options?.pitch || 1.0\n    }\n\n    const audioBuffer = await aiVoiceService.generateSpeech(text, type, voiceOptions)\n    console.log(\"[v0] AI voice generation successful\")\n    return audioBuffer\n  } catch (error) {\n    if (error instanceof AIVoiceError) {\n      console.error(\"[v0] AI Voice Error:\", error.message, \"Provider:\", error.provider)\n    } else {\n      console.error(\"[v0] AI voice generation failed:\", error)\n    }\n    return null\n  }\n}\n\n// Play AudioBuffer using Web Audio API\nexport const playAudioBuffer = async (audioBuffer: AudioBuffer): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    try {\n      const AudioContext = window.AudioContext || (window as any).webkitAudioContext\n      const audioContext = new AudioContext()\n\n      const source = audioContext.createBufferSource()\n      source.buffer = audioBuffer\n      source.connect(audioContext.destination)\n\n      source.onended = () => {\n        console.log(\"[v0] AI voice playback finished\")\n        resolve()\n      }\n\n      // Set up error handling with timeout as fallback\n      const timeoutId = setTimeout(() => {\n        console.error(\"[v0] Audio playback timeout\")\n        reject(new Error(\"Audio playback timeout\"))\n      }, audioBuffer.duration * 1000 + 5000) // Buffer duration + 5 seconds\n\n      source.onended = () => {\n        clearTimeout(timeoutId)\n        console.log(\"[v0] AI voice playback finished\")\n        resolve()\n      }\n\n      source.start(0)\n      console.log(\"[v0] AI voice playback started\")\n    } catch (error) {\n      console.error(\"[v0] Failed to play audio buffer:\", error)\n      reject(error)\n    }\n  })\n}\n\n// Original browser TTS function (renamed for clarity)\nexport const playBrowserTTS = async (text: string, voice: VoiceType, language: Language = \"english\"): Promise<boolean> => {\n  if (typeof window === \"undefined\" || !(\"speechSynthesis\" in window)) {\n    console.error(\"[v0] Speech Synthesis not supported in this browser\")\n    return false\n  }\n\n  // Check if speech synthesis is available and not disabled\n  if (!window.speechSynthesis) {\n    console.error(\"[v0] Speech Synthesis API is not available\")\n    return false\n  }\n\n  // Ensure voices are loaded\n  let voices = window.speechSynthesis.getVoices()\n  if (voices.length === 0) {\n    await new Promise<void>(resolve => {\n      const onVoicesChanged = () => {\n        voices = window.speechSynthesis.getVoices()\n        window.speechSynthesis.removeEventListener('voiceschanged', onVoicesChanged)\n        resolve()\n      }\n      window.speechSynthesis.addEventListener('voiceschanged', onVoicesChanged)\n      // Fallback timeout in case voiceschanged never fires\n      setTimeout(resolve, 1000)\n    })\n  }\n\n  return new Promise((resolve) => {\n    try {\n      // Only cancel if nothing is currently speaking\n      // This allows sequential playback for repetitions\n      if (!window.speechSynthesis.speaking) {\n        window.speechSynthesis.cancel()\n      }\n\n      const utterance = new SpeechSynthesisUtterance(text)\n      const config = VOICE_CONFIG[voice]\n      const langCode = getLanguageCode(language)\n\n      console.log(\"[v0] Available Browser Voices:\", voices.map(v => `${v.name} (${v.lang})`))\n\n      let selectedBrowserVoice: SpeechSynthesisVoice | undefined\n\n      // Helper to find voice by name or gender\n      const findVoice = (keywords: string[], gender: 'male' | 'female') => {\n        // First try to find a voice that matches both language and keywords\n        let match = voices.find(v =>\n          v.lang.startsWith(langCode.split('-')[0]) &&\n          keywords.some(k => v.name.toLowerCase().includes(k))\n        )\n\n        // If no specific match, try to find any voice of the correct gender for the language\n        if (!match) {\n          // Common identifiers for gender in voice names\n          const maleIdentifiers = ['male', 'david', 'james', 'daniel', 'mark', 'george']\n          const femaleIdentifiers = ['female', 'zira', 'samantha', 'susan', 'hazel', 'heather']\n\n          const targetIdentifiers = gender === 'male' ? maleIdentifiers : femaleIdentifiers\n\n          match = voices.find(v =>\n            v.lang.startsWith(langCode.split('-')[0]) &&\n            targetIdentifiers.some(id => v.name.toLowerCase().includes(id))\n          )\n        }\n\n        return match\n      }\n\n      // Map AI voices to browser voice characteristics\n      if (voice === 'openai-onyx' || voice === 'openai-echo' || voice === 'standard-male' || voice === 'azure-guy' || voice === 'azure-davis' || voice === 'elevenlabs-clyde' || voice === 'elevenlabs-drew' || voice === 'elevenlabs-paul') {\n        // Look for male voices\n        selectedBrowserVoice = findVoice(['male', 'david', 'james', 'daniel'], 'male')\n      } else if (voice === 'openai-nova' || voice === 'openai-shimmer' || voice === 'openai-alloy' || voice === 'standard-female' || voice === 'azure-jenny' || voice === 'azure-aria' || voice === 'elevenlabs-rachel') {\n        // Look for female voices\n        selectedBrowserVoice = findVoice(['female', 'zira', 'samantha', 'google us english'], 'female')\n      }\n\n      // If specific match found, use it. Otherwise let browser default for language.\n      if (selectedBrowserVoice) {\n        utterance.voice = selectedBrowserVoice\n        console.log(`[v0] Selected browser voice: ${selectedBrowserVoice.name}`)\n      } else {\n        console.log(`[v0] No specific voice match found, using browser default for ${langCode}`)\n      }\n\n      utterance.pitch = config.pitch\n      utterance.rate = config.rate\n      utterance.volume = config.volume\n      utterance.lang = langCode\n\n      console.log(\"[v0] Playing Browser TTS - Text:\", text.substring(0, 50), \"Voice:\", voice, \"Lang:\", langCode)\n\n      // Event handlers\n      utterance.onstart = () => {\n        console.log(\"[v0] Browser TTS started\")\n      }\n\n      utterance.onend = () => {\n        console.log(\"[v0] Browser TTS finished\")\n        resolve(true)\n      }\n\n      utterance.onerror = (event) => {\n        console.error(\"[v0] Browser TTS error:\", event.error)\n        resolve(false)\n      }\n\n      // Speak immediately\n      window.speechSynthesis.speak(utterance)\n    } catch (error) {\n      console.error(\"[v0] Browser TTS Error:\", error)\n      resolve(false)\n    }\n  })\n}\n\nexport const getLanguageCode = (language: Language): string => {\n  const codes: Record<Language, string> = {\n    english: \"en-US\",\n    hausa: \"ha\",\n    twi: \"ak\",\n    arabic: \"ar\",\n  }\n  return codes[language] || \"en-US\"\n}\n\nexport const translateMessage = (text: string, targetLanguage: Language): string => {\n  // Simple translation dictionary for common messages\n  const translations: Record<Language, Record<string, string>> = {\n    english: {},\n    hausa: {\n      \"should report to the office\": \"ya kamata ya je ofis\",\n      \"your parent is waiting at the gate\": \"mahaifiyar ku tana jira a baje\",\n      \"please come to the staff common room\": \"zo gida mai aiki da fushi\",\n      \"report to the headteacher's office now\": \"je ofis mai shugaba yanzu\",\n    },\n    twi: {\n      \"should report to the office\": \"forow kye ofis no\",\n      \"your parent is waiting at the gate\": \"wo/wo maame/papa retua wɔ apon no\",\n      \"please come to the staff common room\": \"ba stamfo no\",\n      \"report to the headteacher's office now\": \"kɔ ofis osofo mu\",\n    },\n    arabic: {\n      \"should report to the office\": \"يجب أن تتوجه إلى المكتب\",\n      \"your parent is waiting at the gate\": \"والدك ينتظر عند البوابة\",\n      \"please come to the staff common room\": \"يرجى الحضور إلى غرفة الموظفين\",\n      \"report to the headteacher's office now\": \"توجه إلى مكتب مدير المدرسة الآن\",\n    },\n  }\n\n  if (targetLanguage === \"english\") return text\n\n  let translated = text\n  const trans = translations[targetLanguage] || {}\n\n  Object.entries(trans).forEach(([en, local]) => {\n    translated = translated.replace(new RegExp(en, \"gi\"), local)\n  })\n\n  return translated\n}\n\nexport const isTTSAvailable = (): boolean => {\n  return typeof window !== \"undefined\" && \"speechSynthesis\" in window && !!window.speechSynthesis\n}\n\nexport const getTTSStatus = (): { available: boolean; message: string } => {\n  if (typeof window === \"undefined\") {\n    return { available: false, message: \"TTS not available in server environment\" }\n  }\n\n  if (!(\"speechSynthesis\" in window)) {\n    return { available: false, message: \"Speech Synthesis not supported in this browser\" }\n  }\n\n  if (!window.speechSynthesis) {\n    return { available: false, message: \"Speech Synthesis API is not available\" }\n  }\n\n  return { available: true, message: \"TTS is ready\" }\n}\n\n// Get comprehensive voice system status with fallback information\nexport const getVoiceSystemStatus = async (): Promise<{\n  aiVoice: { available: boolean; message: string; providers?: string[] }\n  browserTTS: { available: boolean; message: string }\n  fallback: { available: boolean; recommendation: 'ai' | 'tts' | 'both' | 'none' }\n  recommended: 'ai' | 'tts' | 'none'\n}> => {\n  const aiVoiceService = getAIVoiceService()\n  const ttsStatus = getTTSStatus()\n  const fallbackHandler = getVoiceFallbackHandler()\n\n  let aiVoiceStatus = { available: false, message: \"AI voice not initialized\" }\n  let providers: string[] = []\n\n  if (aiVoiceService) {\n    if (aiVoiceService.isEnabled()) {\n      const hasHealthy = aiVoiceService.hasHealthyProviders()\n      if (hasHealthy) {\n        aiVoiceStatus = { available: true, message: \"AI voice ready\" }\n        // Get available providers\n        const health = aiVoiceService.getProviderHealth()\n        providers = Object.entries(health)\n          .filter(([_, status]) => status.healthy)\n          .map(([provider, _]) => provider)\n      } else {\n        aiVoiceStatus = { available: false, message: \"No healthy AI voice providers\" }\n      }\n    } else {\n      aiVoiceStatus = { available: false, message: \"AI voice disabled\" }\n    }\n  }\n\n  // Get fallback system health\n  const fallbackHealth = await fallbackHandler.checkSystemHealth()\n\n  const recommended = aiVoiceStatus.available ? 'ai' :\n    ttsStatus.available ? 'tts' : 'none'\n\n  return {\n    aiVoice: { ...aiVoiceStatus, providers },\n    browserTTS: ttsStatus,\n    fallback: {\n      available: fallbackHealth.recommendation !== 'none',\n      recommendation: fallbackHealth.recommendation\n    },\n    recommended\n  }\n}\n\n// Check if AI voice is available for a specific type\nexport const isAIVoiceAvailable = (type: 'announcement' | 'prayer' | 'bell' | 'general' = 'general'): boolean => {\n  const aiVoiceService = getAIVoiceService()\n  if (!aiVoiceService || !aiVoiceService.isEnabled()) {\n    return false\n  }\n\n  const settings = aiVoiceService.getSettings()\n  const voiceProfile = settings.voiceProfiles[type]\n\n  if (!voiceProfile) {\n    return false\n  }\n\n  const health = aiVoiceService.getProviderHealth()\n  const providerHealth = health[voiceProfile.provider as keyof typeof health]\n\n  return providerHealth?.healthy || false\n}\n\n// Get cost estimate for text\nexport const estimateVoiceCost = async (\n  text: string,\n  type: 'announcement' | 'prayer' | 'bell' | 'general' = 'general'\n): Promise<{ cost: number; provider: string; cached: boolean } | null> => {\n  const aiVoiceService = getAIVoiceService()\n  if (!aiVoiceService || !aiVoiceService.isEnabled()) {\n    return null\n  }\n\n  try {\n    return await aiVoiceService.estimateCost(text, type)\n  } catch (error) {\n    console.error(\"[v0] Cost estimation failed:\", error)\n    return null\n  }\n}\n\n// Play announcement with repeat functionality\nexport const playAnnouncement = async (\n  text: string,\n  voice?: VoiceType,\n  language?: Language,\n  repeatCount?: number\n): Promise<boolean> => {\n  const { useStore } = await import(\"./store\")\n  const settings = useStore.getState().settings\n\n  const selectedVoice = voice || settings.defaultVoice\n  const selectedLanguage = language || settings.defaultLanguage\n  const timesToRepeat = repeatCount ?? settings.defaultRepeatCount ?? 1\n\n  console.log(`[v0] Playing announcement ${timesToRepeat} time(s)`)\n\n  let allSuccessful = true\n\n  for (let i = 0; i < timesToRepeat; i++) {\n    console.log(`[v0] Announcement repetition ${i + 1} of ${timesToRepeat}`)\n\n    const fallbackHandler = getVoiceFallbackHandler()\n    const result = await fallbackHandler.playWithFallback(text, selectedVoice, selectedLanguage, 'announcement', {\n      maxRetries: 2,\n      retryDelay: 1000,\n      preferAI: true,\n      fallbackToTTS: true,\n      logErrors: true\n    })\n\n    if (!result.success) {\n      allSuccessful = false\n      console.error(`[v0] Announcement repetition ${i + 1} failed`)\n    }\n\n    // Add delay between repetitions (except for the last one)\n    if (i < timesToRepeat - 1) {\n      await new Promise(resolve => setTimeout(resolve, 2000)) // 2 second delay for announcements\n    }\n  }\n\n  console.log(`[v0] Announcement completed. ${timesToRepeat} repetitions. Success: ${allSuccessful}`)\n  return allSuccessful\n}\n\nexport const playAzanCall = async (prayerName: string) => {\n  // Enhanced prayer call with traditional Islamic phrases\n  const azanText = generatePrayerCallText(prayerName)\n\n  // Use the comprehensive fallback system with prayer-specific settings\n  const fallbackHandler = getVoiceFallbackHandler()\n  const result = await fallbackHandler.playWithFallback(azanText, \"azan-islamic\", \"arabic\", 'prayer', {\n    maxRetries: 2, // More retries for important prayer calls\n    retryDelay: 1000,\n    preferAI: true,\n    fallbackToTTS: true,\n    logErrors: true // Log errors for prayer calls\n  })\n\n  if (result.success) {\n    console.log(`[v0] Prayer call played successfully using ${result.method} (${result.provider || 'browser'})`)\n  } else {\n    console.error(`[v0] Prayer call failed: ${result.error}`)\n  }\n\n  return result.success\n}\n\n// Generate traditional Islamic prayer call text using the comprehensive generator\nexport const generatePrayerCallText = (prayerName: string): string => {\n  // Import here to avoid circular dependencies\n  const { generateSchoolPrayerCall } = require(\"./prayer-call-generator\")\n\n  // Generate school-appropriate prayer call\n  return generateSchoolPrayerCall(prayerName, true)\n}\n","import { playHighQualityAnnouncement, playNormalAnnouncement } from \"./combined-audio\"\r\nimport type { VoiceType, Language } from \"./store\"\r\n\r\n/**\r\n * High-Quality AI Voice Announcement System\r\n * Uses premium AI voices for crystal-clear announcements\r\n */\r\n\r\nexport interface HighQualityAnnouncementOptions {\r\n  voice?: VoiceType\r\n  language?: Language\r\n  repeatCount?: number\r\n  withTone?: boolean\r\n}\r\n\r\nexport class HighQualityAnnouncementSystem {\r\n  // Premium AI voices for different announcement types\r\n  static readonly PREMIUM_VOICES = {\r\n    professional: \"openai-nova\" as VoiceType,      // Clear, professional female\r\n    authoritative: \"openai-onyx\" as VoiceType,     // Deep, authoritative male\r\n    friendly: \"openai-shimmer\" as VoiceType,       // Bright, friendly female\r\n    warm: \"openai-echo\" as VoiceType,              // Warm, rounded male\r\n    storytelling: \"openai-fable\" as VoiceType,     // British accent, engaging\r\n    balanced: \"openai-alloy\" as VoiceType,         // Neutral, balanced\r\n    elevenlabs: \"elevenlabs-rachel\" as VoiceType,  // Premium ElevenLabs voice\r\n    azure: \"azure-aria\" as VoiceType               // Microsoft Azure premium\r\n  }\r\n\r\n  // Play a custom announcement with high-quality AI voice\r\n  static async playCustomAnnouncement(\r\n    message: string,\r\n    options: HighQualityAnnouncementOptions = {}\r\n  ): Promise<boolean> {\r\n    const {\r\n      voice = this.PREMIUM_VOICES.professional,\r\n      language = \"english\",\r\n      repeatCount = 1,\r\n      withTone = false\r\n    } = options\r\n\r\n    console.log(`[HighQuality] Playing custom announcement with ${voice}`)\r\n    console.log(`[HighQuality] Message: \"${message}\"`)\r\n\r\n    if (withTone) {\r\n      return playNormalAnnouncement(message, {\r\n        voice,\r\n        language,\r\n        repeatCount\r\n      })\r\n    } else {\r\n      return playHighQualityAnnouncement(message, {\r\n        voice,\r\n        language,\r\n        repeatCount\r\n      })\r\n    }\r\n  }\r\n\r\n  // Professional school announcements\r\n  static async playSchoolAnnouncement(\r\n    title: string,\r\n    details: string,\r\n    options: HighQualityAnnouncementOptions = {}\r\n  ): Promise<boolean> {\r\n    const message = `Attention all students and staff. ${title}. ${details}`\r\n    \r\n    return this.playCustomAnnouncement(message, {\r\n      voice: this.PREMIUM_VOICES.professional,\r\n      withTone: true,\r\n      ...options\r\n    })\r\n  }\r\n\r\n  // Emergency announcements with authoritative voice\r\n  static async playEmergencyAnnouncement(\r\n    emergency: string,\r\n    instructions: string,\r\n    options: HighQualityAnnouncementOptions = {}\r\n  ): Promise<boolean> {\r\n    const message = `Emergency alert. ${emergency}. ${instructions}. Please follow all safety procedures immediately.`\r\n    \r\n    return this.playCustomAnnouncement(message, {\r\n      voice: this.PREMIUM_VOICES.authoritative,\r\n      withTone: true,\r\n      repeatCount: 2,\r\n      ...options\r\n    })\r\n  }\r\n\r\n  // Friendly announcements for positive news\r\n  static async playFriendlyAnnouncement(\r\n    message: string,\r\n    options: HighQualityAnnouncementOptions = {}\r\n  ): Promise<boolean> {\r\n    return this.playCustomAnnouncement(message, {\r\n      voice: this.PREMIUM_VOICES.friendly,\r\n      withTone: true,\r\n      ...options\r\n    })\r\n  }\r\n\r\n  // Administrative announcements\r\n  static async playAdministrativeAnnouncement(\r\n    message: string,\r\n    options: HighQualityAnnouncementOptions = {}\r\n  ): Promise<boolean> {\r\n    return this.playCustomAnnouncement(message, {\r\n      voice: this.PREMIUM_VOICES.balanced,\r\n      withTone: true,\r\n      ...options\r\n    })\r\n  }\r\n\r\n  // Test all premium voices\r\n  static async testAllPremiumVoices(): Promise<void> {\r\n    console.log(\"🎤 Testing All Premium AI Voices\")\r\n    console.log(\"=\" .repeat(50))\r\n\r\n    const testMessage = \"This is a test of the high-quality announcement system.\"\r\n    \r\n    for (const [name, voice] of Object.entries(this.PREMIUM_VOICES)) {\r\n      console.log(`\\n🔊 Testing ${name} voice (${voice})`)\r\n      \r\n      await this.playCustomAnnouncement(testMessage, {\r\n        voice,\r\n        repeatCount: 1,\r\n        withTone: false\r\n      })\r\n      \r\n      // Wait between tests\r\n      await new Promise(resolve => setTimeout(resolve, 4000))\r\n    }\r\n    \r\n    console.log(\"\\n✅ Premium voice testing completed!\")\r\n  }\r\n\r\n  // Demonstrate different announcement types\r\n  static async demonstrateAnnouncementTypes(): Promise<void> {\r\n    console.log(\"📢 Demonstrating High-Quality Announcement Types\")\r\n    console.log(\"=\" .repeat(60))\r\n\r\n    const demonstrations = [\r\n      {\r\n        type: \"School Announcement\",\r\n        func: () => this.playSchoolAnnouncement(\r\n          \"Morning Assembly\",\r\n          \"All students please proceed to the main hall for our weekly assembly\"\r\n        )\r\n      },\r\n      {\r\n        type: \"Emergency Announcement\", \r\n        func: () => this.playEmergencyAnnouncement(\r\n          \"Fire drill in progress\",\r\n          \"Please exit the building using the nearest emergency exit\"\r\n        )\r\n      },\r\n      {\r\n        type: \"Friendly Announcement\",\r\n        func: () => this.playFriendlyAnnouncement(\r\n          \"Congratulations to our basketball team for winning the championship! Well done everyone!\"\r\n        )\r\n      },\r\n      {\r\n        type: \"Administrative Announcement\",\r\n        func: () => this.playAdministrativeAnnouncement(\r\n          \"Reminder that parent-teacher conferences are scheduled for next week. Please check your emails for appointment times.\"\r\n        )\r\n      },\r\n      {\r\n        type: \"Custom High-Quality\",\r\n        func: () => this.playCustomAnnouncement(\r\n          \"This is a demonstration of our premium AI voice system with crystal-clear audio quality.\",\r\n          { voice: this.PREMIUM_VOICES.elevenlabs, withTone: false }\r\n        )\r\n      }\r\n    ]\r\n\r\n    for (const demo of demonstrations) {\r\n      console.log(`\\n🎯 ${demo.type}`)\r\n      await demo.func()\r\n      \r\n      // Wait between demonstrations\r\n      await new Promise(resolve => setTimeout(resolve, 6000))\r\n    }\r\n\r\n    console.log(\"\\n✅ All announcement type demonstrations completed!\")\r\n  }\r\n\r\n  // Quick test with the best voice\r\n  static async quickHighQualityTest(): Promise<void> {\r\n    console.log(\"⚡ Quick High-Quality Voice Test\")\r\n    \r\n    await this.playCustomAnnouncement(\r\n      \"Attention all students, this is a test of our premium AI voice announcement system. The audio quality should be crystal clear and professional.\",\r\n      {\r\n        voice: this.PREMIUM_VOICES.professional,\r\n        withTone: true,\r\n        repeatCount: 1\r\n      }\r\n    )\r\n    \r\n    console.log(\"✅ Quick test completed!\")\r\n  }\r\n\r\n  // Get available premium voices\r\n  static getAvailablePremiumVoices(): Array<{name: string, voice: VoiceType, description: string}> {\r\n    return [\r\n      { name: \"Professional\", voice: this.PREMIUM_VOICES.professional, description: \"Clear, professional female voice\" },\r\n      { name: \"Authoritative\", voice: this.PREMIUM_VOICES.authoritative, description: \"Deep, authoritative male voice\" },\r\n      { name: \"Friendly\", voice: this.PREMIUM_VOICES.friendly, description: \"Bright, friendly female voice\" },\r\n      { name: \"Warm\", voice: this.PREMIUM_VOICES.warm, description: \"Warm, rounded male voice\" },\r\n      { name: \"Storytelling\", voice: this.PREMIUM_VOICES.storytelling, description: \"British accent, engaging voice\" },\r\n      { name: \"Balanced\", voice: this.PREMIUM_VOICES.balanced, description: \"Neutral, balanced voice\" },\r\n      { name: \"ElevenLabs Premium\", voice: this.PREMIUM_VOICES.elevenlabs, description: \"Premium ElevenLabs voice\" },\r\n      { name: \"Azure Premium\", voice: this.PREMIUM_VOICES.azure, description: \"Microsoft Azure premium voice\" }\r\n    ]\r\n  }\r\n}\r\n\r\n// Export convenience functions\r\nexport const playCustomAnnouncement = (message: string, options?: HighQualityAnnouncementOptions) =>\r\n  HighQualityAnnouncementSystem.playCustomAnnouncement(message, options)\r\n\r\nexport const playSchoolAnnouncement = (title: string, details: string, options?: HighQualityAnnouncementOptions) =>\r\n  HighQualityAnnouncementSystem.playSchoolAnnouncement(title, details, options)\r\n\r\nexport const playEmergencyAnnouncement = (emergency: string, instructions: string, options?: HighQualityAnnouncementOptions) =>\r\n  HighQualityAnnouncementSystem.playEmergencyAnnouncement(emergency, instructions, options)\r\n\r\nexport const playFriendlyAnnouncement = (message: string, options?: HighQualityAnnouncementOptions) =>\r\n  HighQualityAnnouncementSystem.playFriendlyAnnouncement(message, options)\r\n\r\nexport const playAdministrativeAnnouncement = (message: string, options?: HighQualityAnnouncementOptions) =>\r\n  HighQualityAnnouncementSystem.playAdministrativeAnnouncement(message, options)\r\n\r\nexport const testAllPremiumVoices = () => HighQualityAnnouncementSystem.testAllPremiumVoices()\r\n\r\nexport const demonstrateAnnouncementTypes = () => HighQualityAnnouncementSystem.demonstrateAnnouncementTypes()\r\n\r\nexport const quickHighQualityTest = () => HighQualityAnnouncementSystem.quickHighQualityTest()\r\n\r\nexport const getAvailablePremiumVoices = () => HighQualityAnnouncementSystem.getAvailablePremiumVoices()\r\n\r\n// Make it available globally for console testing\r\nif (typeof window !== \"undefined\") {\r\n  (window as any).HighQualityAnnouncementSystem = HighQualityAnnouncementSystem;\r\n  (window as any).playCustomAnnouncement = playCustomAnnouncement;\r\n  (window as any).playSchoolAnnouncement = playSchoolAnnouncement;\r\n  (window as any).playEmergencyAnnouncement = playEmergencyAnnouncement;\r\n  (window as any).playFriendlyAnnouncement = playFriendlyAnnouncement;\r\n  (window as any).playAdministrativeAnnouncement = playAdministrativeAnnouncement;\r\n  (window as any).testAllPremiumVoices = testAllPremiumVoices;\r\n  (window as any).demonstrateAnnouncementTypes = demonstrateAnnouncementTypes;\r\n  (window as any).quickHighQualityTest = quickHighQualityTest;\r\n  (window as any).getAvailablePremiumVoices = getAvailablePremiumVoices;\r\n}"],"names":[],"mappings":"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"}